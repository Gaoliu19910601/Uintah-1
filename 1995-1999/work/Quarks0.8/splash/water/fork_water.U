MAIN_ENV
#include "stdio.h"
#include "comments.h"	/* moves leading comments to another file */
#include "split.h"

/*  include files for declarations  */
#define extern
#include "parameters.h"
#include "water.h"
#include "mddata.h"
#include "fileio.h"
#include "frcnst.h"
#include "randno.h"
#include "global.h"
#undef extern

unsigned long voodoo_start_time;

unsigned long start_time, end_time;

struct GlobalMemory *gl;        /* pointer to the Global Memory
                                structure, which contains the lock,
                                barrier, and some scalar variables */
                                
double  TEMP,RHO,TSTEP,BOXL,BOXH,CUTOFF,CUT2;
int    NMOL,NORDER,NATMO,NATMO3,NMOL1;
double OMAS,HMAS,WTMOL,ROH,ANGLE,FHM,FOM,ROHI,ROHI2;
int NATOMS;
double  QQ,A1,B1,A2,B2,A3,B3,A4,B4,AB1,AB2,AB3,AB4,C1,C2,
               QQ2,QQ4,REF1,REF2,REF4;
double UNITT,UNITL,UNITM,BOLTZ,AVGNO,PCC[11];

molecule_type *VAR;

double  TLC[100],
      ELPST,TKIN,TVIR,TTMV,FPOT,FKIN;
int IX[3*MXOD2+1], IRST,NVAR,NXYZ,NXV,IXF,IYF,IZF,IMY,IMZ;

int procid;
int StartMol[MAXPROCS+1];
int StartPos[MAXPROCS+1];
int MolsPerProc;
int NumProcs;

int NSTEP, NSAVE, NRST, NPRINT,NFMC;
int NORD1;
int II;                         /*  variables explained in common.h */
int i;
int NDATA;
int   NFRST=11;
int  NFSV=10;
int  LKT=0;

int procid;                     /* process id; one per process */
int StartMol[MAXPROCS+1];       /* number of the first molecule
                                   to be handled by this process; used
                                   for static scheduling     */ 
int MolsPerProc;                /* number of mols per processor */ 
int NumProcs;                   /* number of processors being used; 
                                   run-time input           */

/* forward reference: */
extern int WorkStart(void);

/* external references */
extern double  MDMAIN(int NFSV, int NFRST, int NSTEP, int NRST,
		      int NPRINT, int NSAVE, int LKT, int NORD1);
extern int INITIA(FILE *);
extern int INTRAF(double *);
extern int SYSCNS();
extern int CNSTNT(int, double *);
extern int INTERF(int, double *);

#define NPROC NumProcs

main(int argc, char *argv[])
{
    int mol, func, dir, atom;
    double XTT;
    double VIR;
    int extra;
    unsigned long st, et;

/*
    int dummy;
    FILE *infp;
    char infile[256];
*/

    /* default values for the control parameters of the driver */
    /* are in parameters.h */

    dostats = 1;

/*	
    sprintf(infile,
       "/n/sunset/home/cs/grad/khands/Quarksa/splash/water/sample.in");

    infp = fopen(infile, "r");
    if (!infp)
    {
        printf("File sample.in not found. Cannot proceed. \n");
	exit(0);
    }
    fscanf(infp, "%lf%d%d%d%d%d%d%d%d", &TSTEP, &NMOL, &NSTEP, &NORDER, 
	   &NSAVE, &NRST, &NPRINT, &NFMC, &NumProcs);
    fclose(infp);
*/

    QUARKS_INIT();

    six = fopen("LWO6","w");  /* output file */
    TEMP  =298.0;
    RHO   =0.9980;
    CUTOFF=0.0;

   /* READ INPUT */

    /*
     *   TSTEP = time interval between steps
     *   NMOL  = number of molecules to be simulated
     *   NSTEP = number of time-steps to be simulated
     *   NORDER = order of the predictor-corrector method. 6 by default
     *   NSAVE = frequency of data saving.  -1 by default
     *   NRST  = no longer used
     *   NPRINT = frequency (in time-steps) of computing pot. energy and
     *            writing output file.  setting it larger than NSTEP
     *            means not doing any I/O until the very end.
     *   NFMC = file number to read initial displacements from.  set to 
     *          0 if program should generate a regular lattice initially.
     *   NumProcs = number of processors to be used.
     */

    
    scanf("%lf%d%d%d%d%d%d%d%d", &TSTEP, &NMOL, &NSTEP, &NORDER, 
	   &NSAVE, &NRST, &NPRINT, &NFMC, &NumProcs);

    if (NMOL > MAXMOLS) {
	fprintf(stderr, "Lock array in global.H has size %d < %d (NMOL)\n",
							MAXMOLS, NMOL);
	exit(-1);
    }

    printf("Using %d procs on %d steps of %d mols\n", NumProcs, NSTEP, NMOL);

    /* SET UP SCALING FACTORS AND CONSTANTS */

    NORD1=NORDER+1;

    CNSTNT(NORD1,TLC);  /* sub. call to set up constants */

    fprintf(six,"\nTEMPERATURE                = %8.2f K\n",TEMP);
    fprintf(six,"DENSITY                    = %8.5f G/C.C.\n",RHO);
    fprintf(six,"NUMBER OF MOLECULES        = %8d\n",NMOL);
    fprintf(six,"NUMBER OF PROCESSORS       = %8d\n",NumProcs);
    fprintf(six,"TIME STEP                  = %8.2e SEC\n",TSTEP);
    fprintf(six,"ORDER USED TO SOLVE F=MA   = %8d \n",NORDER);
    fprintf(six,"NO. OF TIME STEPS          = %8d \n",NSTEP);
    fprintf(six,"FREQUENCY OF DATA SAVING   = %8d \n",NSAVE);
    fprintf(six,"FREQUENCY TO WRITE RST FILE= %8d \n",NRST);

    { /* Do memory initializations */
	int pid;
	unsigned mol_size = sizeof(molecule_type) * NMOL;
	unsigned gmem_size = sizeof(struct GlobalMemory);
	MAIN_INITENV();  /* macro call to initialize
                            shared memory etc. */
      /* allocate space for main (VAR) data structure as well as
           synchronization variables */
	G_MALLOC(mol_size, &VAR);
	G_MALLOC(gmem_size, &gl);
	/* 
	VAR = (molecule_type *) G_MALLOC(mol_size, &VAR);
	gl = (struct GlobalMemory *) G_MALLOC(gmem_size, &gl);
	*/
        gl->initialized = 0;

             /* macro calls to initialize synch varibles  */

	BARINIT(gl->start)
	BARINIT(gl->InterfBar)
	BARINIT(gl->PotengBar)
        LOCKINIT(gl->IntrafVirLock)
        LOCKINIT(gl->InterfVirLock)
        LOCKINIT(gl->FXLock)
        LOCKINIT(gl->FYLock)
        LOCKINIT(gl->FZLock)
	ALOCKINIT(gl->MolLock, NMOL)
	LOCKINIT(gl->KinetiSumLock)
	LOCKINIT(gl->PotengSumLock)

	printf("Trying to associate locks with regions\n");

	assoc_wsregion_with_lock((char *) VAR, 
				 (char *) VAR + mol_size,
				 gl->IntrafVirLock);
	assoc_wsregion_with_lock((char *) VAR,
				 (char *) VAR + mol_size,
				 gl->InterfVirLock);
	for (i=0; i<NMOL; i++)
	    assoc_wsregion_with_lock((char *) &VAR[i],
				     (char *) &VAR[i] + sizeof(molecule_type),
				     gl->MolLock[i]);
	assoc_wsregion_with_lock((char *) &gl->SUM[0],
				 (char *) &gl->SUM[0] + 3*sizeof(double),
				 gl->KinetiSumLock);
	assoc_wsregion_with_lock((char *) &gl->POTA,
				 (char *) &gl->POTA + 3*sizeof(double),
				 gl->PotengSumLock);

	printf("Done all the associating\n");

            /* set up control for static scheduling */

	MolsPerProc = NMOL/NumProcs;
	extra = NMOL % NumProcs;
	StartMol[0] = 0;
	for (pid = 1; pid < NumProcs; pid += 1) {
          StartMol[pid] = StartMol[pid-1] + MolsPerProc;
	  if (pid <= extra) StartMol[pid]++;
        }
	StartMol[NumProcs] = NMOL;

      }

    SYSCNS();    /* sub. call to initialize system constants  */

    fprintf(six,"SPHERICAL CUTOFF RADIUS    = %8.4f ANGSTROM\n",CUTOFF);
    fflush(six);

    IRST=0;

            /* if there is no input displacement file, and we are to
               initialize to a regular lattice */
    if (NFMC != 0) nfmc = fopen("LWI12","r"); /* input file for particle
                                  displacements */
    else nfmc = NULL;


            /* initialization routine; also reads displacements and
             sets up random velocities*/
    INITIA(nfmc);

    /*.......ESTIMATE ACCELERATION FROM F/M */
    {       
            /* note that these initial calls to the force-computing 
               routines  (INTRAF and INTERF) use only 1 process since 
               others haven't been created yet */
    int tmp_procs = NumProcs;
    int tmp_smol = StartMol[1];
    procid = 0;
    StartMol[0] = 0;
    StartMol[1] = NMOL;
    NumProcs = 1;
    INTRAF(&VIR);
    INTERF(ACC,&VIR);
    StartMol[1] = tmp_smol;
    NumProcs = tmp_procs;
    }  /* Acclerations estimated */

    NFMC= -1;

    /*.....START MOLECULAR DYNAMIC LOOP */
    if (NFMC < 0) {
  	ELPST=0.00;
        TKIN=0.00;
        TVIR=0.00;
        TTMV=0.00;
    };

    end_time = Qk_current_time();
    fprintf(stderr, "Time for initialization: %lf sec\n",
	(double)(end_time - start_time)/1000000.0);

    start_time = Qk_current_time();
       /* spawn helper processes, each getting its unique process id */
    for (procid = 1; procid < NumProcs; procid += 1) {
	CREATE(WorkStart);
    }
    end_time = Qk_current_time();
    fprintf(stderr, "Time for remote fork: %lf sec\n",
	(double) (end_time - start_time)/1000000.0);

    start_time = Qk_current_time();
    procid = 0; /* process id of main process */

    if (NSAVE > 0)  /* not true for input decks provided */
      fprintf(six,"COLLECTING X AND V DATA AT EVERY %4d TIME STEPS \n",NSAVE);

            /* call routine to do the timesteps */
    st = Qk_current_time();
    XTT = MDMAIN(NFSV,NFRST,NSTEP,NRST,NPRINT,NSAVE,LKT,NORD1); 
    et = Qk_current_time();
    printf("Time for MDMAIN = %lf sec.\n",
		(double) (et - st)/1000000.0);
 

            /* macro to make main process wait for all others to finish */
    WAIT_FOR_END(NumProcs-1)

            /* signal completion to verification output file LWV */
    one = fopen("LWV","w");
    fprintf(one, "\nExited Happily with XTT %g\n", XTT);


    MAIN_END
} /* main.c */

WorkStart() /* routine that each created process starts at;
              it simply calls the timestep routine */
{
    int i;
    char *ch;
    char dummy;
    unsigned long st, et;

    printf("Prefetching..."); fflush(stdout);
    ch = (char *) gl;
    for (i=0; i<sizeof(*gl); i++)
    {
	dummy = *ch;
	ch++;
    }

    ch = (char *) VAR;
    for (i=0; i<sizeof(*VAR); i++)
    {
	dummy = *ch;
	ch++;
    }
    printf("done!\n");

    st = Qk_current_time();	
    (void) MDMAIN(NFSV,NFRST,NSTEP,NRST,NPRINT,NSAVE,LKT,NORD1);
    et = Qk_current_time();
 
    printf("Execution time = %lf sec.\n",
		(double) (et - st)/1000000.0);

    print_stats();
}
