divert(-1)
define(ENDLAB, 5283) dnl
define(SH_MEM, 20000000)

define(SLINIT, `
{
  $1 = usnewlock (sc_handle);
  if ($1 == NULL) {
    perror ("");
    fprintf (stderr, "Error in sync variable $1 creation.\n"); exit (-1);
  }
}')

define(SEMINIT, `
{
  $1 = usnewsema (sc_handle, $2);
  if ($1 == NULL) {
    perror ("");
    fprintf (stderr, "Error in sync variable $1 creation.\n"); exit (-1);
  }
  if (usinitsema ($1, $2) == -1) {
    perror ("");
    fprintf (stderr, "Error in sync variable $1 initialization.\n"); exit (-1);
  }
}')
define(SPINLOCK, `
{
  if (ussetlock ($1) != 1) {
    perror (""); fprintf (stderr, "Lock $1 failed.\n"); exit (-1); 
  }
}')
define(RELEASELOCK, `{ usunsetlock ($1); }')
define(ENQUEUE, `
{
  if (uspsema ($1) == -1) {
    perror (""); fprintf (stderr, "Lock $1 failed.\n"); exit (-1); 
  }
}')
define(DEQUEUE, `{ usvsema ($1); }')

define(SYS_MONINIT, ` 
{
  int mon_dum1, mon_dum2;

  ifelse(eval($2 > 0),1, `
  for (mon_dum1 = 0; mon_dum1 < $3; mon_dum1++)
    for (mon_dum2 = 0; mon_dum2 < $2; mon_dum2++) {
      $1[mon_dum1].count[mon_dum2] = 0;
      SEMINIT($1[mon_dum1].queue[mon_dum2], 0)
    }' ,,)

  for (mon_dum1 = 0; mon_dum1 < $3; mon_dum1++) 
    SLINIT($1[mon_dum1].lock, 1)
}')
define(SYS_MENTER, `SPINLOCK($1[$2].lock);')
define(SYS_DELAY, `
{
  $1[$3].count[$2]++;
  RELEASELOCK($1[$3].lock)
  ENQUEUE($1[$3].queue[$2]);   
}')
define(SYS_CONTINUE, `
{
  if ($1[$3].count[$2]) {
    ($1[$3].count[$2])--;
    DEQUEUE($1[$3].queue[$2])   
  } else
    RELEASELOCK($1[$3].lock)   
  goto `L'ENDLAB;
`LGO'ENDLAB: ;
}')
define(SYS_MEXIT, `
{
  RELEASELOCK($1[$2].lock); `L'ENDLAB: ; 
  define(`ENDLAB', eval(ENDLAB+1))
}')

define(DECVAR, `
  struct $1TYP {                                                    
    ulock_t lock;
    ifelse(eval($2 > 0), 1, `int count[$2]; usema_t *queue[$2];',)
    $4                       
  } $1[$3];
')
    
define(CREATE, `
{
  int rc;

  fflush (stdout);
  fflush (stderr);
  rc = fork ();
  if (rc == 0)  {
    $1 (); exit (0);
  } else if (rc == -1) {
    perror(""); fprintf (stderr, "failure in create\n"); exit (-1);
  }
  sc_myid++;
}')

define(CLOCK, `
{
  if (gettimeofday (&sc_tp, (struct timezone *)0)) {
    perror (""); fprintf ("error in clock macro\n"); exit (-1); }
  $1 = (sc_tp.tv_sec & 0x7ff)*1000000 + sc_tp.tv_usec;
}')

define(INCLUDES, `
#include <stdio.h>
#include <sys/types.h>
#include <ulocks.h>
#include <sys/signal.h>
#include <sys/file.h>
#include <sys/time.h>
#include <errno.h>
#ifndef w_coredump
#include <sys/wait.h>
#endif
  void perror (), exit ();
  unsigned *share_malloc ();
')
define(MAIN_ENV, `
  INCLUDES
  int shmem_range_lo, shmem_range_hi;
  int sc_myid = 0;
  usptr_t *sc_handle;
  struct timeval sc_tp;
')
define(EXTERN_ENV, `
  INCLUDES
  extern int shmem_range_lo, shmem_range_hi;
  extern int sc_myid;
  extern usptr_t *sc_handle;
  extern struct timeval sc_tp;
')

define(INITENV, `
{ 
  char filespec[256];
  unsigned short getuid();

  ifelse($2,,,`define(`SH_MEM',$2)')
  share_malloc_init (SH_MEM);
  (void)sprintf (filespec, "/usr/local/lib/tango/locks/%u", getuid());
  sc_handle = usinit (filespec);
  if (sc_handle == NULL) {
    perror (""); printf (stderr, "unable to access lock file %s\n", filespec);
    exit (-1);
  }
  
}')
define(MAIN_INITENV, `INITENV($1,$2)')
define(MAIN_END, `{ remove_shmem (); exit (ifelse($1,,0,$1));}')

define(NU_MALLOC, `share_malloc ($1);')
define(G_MALLOC, `share_malloc ($1);')
define(NU_FREE, `share_free ($1);')
define(G_FREE, `share_free ($1);')
define(SET_HOME, `{}')

define(WAIT_FOR_END,`{ int i; for (i = 1; i <= $1; i++) wait (0); }')

define(GET_PID,
`{
  $1 = sc_myid;
}')
define(AUG_OFF, ` ')
define(AUG_ON, ` ')
define(ST_LOG, ` ')
define(ST_INFO_INIT, ` ')
divert(0)
divert(-1)
define(MENTER,
`{
  AUG_OFF
  ST_LOG(ST_MENTER, (int *)&($1[$2].lock));
  SYS_MENTER($1, $2)
  AUG_ON
}')
    
define(MEXIT,
`{
  AUG_OFF
  ST_LOG(ST_MEXIT, (int *)&($1[$2].lock));
  SYS_MEXIT($1, $2)
  AUG_ON
}')
    
define(DELAY,
`{
  AUG_OFF
  ST_LOG(ST_DELAY, (int *)&($1[$3].lock));
  SYS_DELAY($1, $2, $3)
  AUG_ON
}')

define(CONTINUE,
`{
  AUG_OFF
  ST_LOG(ST_CONTINUE, (int *)&($1[$3].lock));
  SYS_CONTINUE($1, $2, $3)
  AUG_ON
}')

define(MONINIT, 
`{
  AUG_OFF
  SYS_MONINIT($1, $2, $3)
  AUG_ON
}')

define(BARRIER, 
`{
    register int *lockAddr;

    AUG_OFF
    lockAddr = (int *)&($1[0].lock);
    ST_LOG(ST_BAR_ENTER, lockAddr)
    SYS_MENTER($1, 0)
    if ( $1[0].count[0] < ($2 -1) ) {
	SYS_DELAY($1, 0, 0)
        ST_LOG(ST_BAR_EXIT, lockAddr)
    } else {
        ST_LOG(ST_BAR_EXIT_LAST, lockAddr)
    }
    SYS_CONTINUE($1,0,0)
    SYS_MEXIT($1,0)
    AUG_ON
}')

define(BARDEC, `DECVAR($1,1,1,)')

define(BARINIT, 
`{
  AUG_OFF
  SYS_MONINIT($1,1,1)
  ST_INFO_INIT($1, ST_BAR_LOCK, &($1[0].lock) )
  ST_INFO_INIT($1, ST_BAR_QUEUE, &($1[0].queue[0]) )
  ST_LOG(ST_BAR_INIT, (int *)&($1[0].lock))
  AUG_ON
}')

define(GSDEC, `DECVAR($1,1,1,`int sub;')')

define(GSINIT, 
`{
  AUG_OFF
  SYS_MONINIT($1,1,1)
  $1[0].sub = 0;
  ST_INFO_INIT($1, ST_GS_LOCK, &($1[0].lock) )
  ST_INFO_INIT($1, ST_GS_QUEUE, &($1[0].queue[0]) )
  ST_LOG(ST_GS_INIT, (int *)&($1[0].lock))
  AUG_ON
}')

define(GETSUB, 
`{
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[0].lock);
  ST_LOG(ST_GS_ENTER, lockAddr)
  SYS_MENTER($1, 0);
  if ($1[0].sub <= $3) {
    $2 = $1[0].sub++;
    ST_LOG(ST_GS_EXIT, lockAddr)
  } else {
    $2 = -1;
    if ($1[0].count[0] < ($4 - 1)) {
      SYS_DELAY($1,0,0)
    } else {
      $1[0].sub = 0;
    }
    ST_LOG(ST_GS_EXIT_LAST, lockAddr)
    SYS_CONTINUE($1,0,0)
  }
  SYS_MEXIT($1,0)
  AUG_ON
}')

define(NU_GSDEC, `DECVAR($1,1,1,`int *s, ssize, sub, mapsize; char *map;')')

define(NU_GSINIT, 
`{
  AUG_OFF
  SYS_MONINIT($1,1,1)
  $1[0].s = NULL;
  $1[0].ssize = 0;
  $1[0].sub = 0;
  $1[0].mapsize = 0;
  $1[0].map = NULL;
  ST_INFO_INIT($1, ST_GS_LOCK, &($1[0].lock) )
  ST_INFO_INIT($1, ST_GS_QUEUE, &($1[0].queue[0]) )
  ST_LOG(ST_GS_INIT, (int *)&($1[0].lock))
  AUG_ON
}')

define(NU_GETSUB, 
`{
  int *lockAddr, ti;
  AUG_OFF
  lockAddr = (int *)&($1[0].lock);
  ST_LOG(ST_GS_ENTER, lockAddr)
  SYS_MENTER($1, 0);
  if (($1)[0].mapsize < ($3)+1) {
    if (($1)[0].map != NULL)
      share_free (($1)[0].map);
    ($1)[0].map = (char *)nu_share_malloc(sizeof(char)*(($3)+1), PAGE_FORTANGO);
    ($1)[0].mapsize = ($3)+1;
    for (ti = 0; ti <= ($3); ti++) 
      ($1)[0].map[ti] = 0;
  }
  if (($1)[0].ssize < ($4)) {
    if (($1)[0].s != NULL)
      share_free (($1)[0].s);
    ($1)[0].s = (int *)nu_share_malloc(sizeof(int)*($4), PAGE_FORTANGO);
    ($1)[0].ssize = ($4);
    for (ti = 0; ti < ($4); ti++) 
      ($1)[0].s[ti] = 0;
  }
  if (($1)[0].sub <= ($3)) {
    if (($1)[0].s[st_threadID] <= ($3)) {
      ($2) = ($1)[0].s[st_threadID];
      while (($2) <= ($3) && ($1[0].map[$2] || nu_home ((char *)$5) != ($6)))
        ($2)++;
      if (($2) > ($3)) 
        ($2) = ($1)[0].sub;
    } else
      ($2) = ($1)[0].sub;
    ($1)[0].map[$2] = 1;
    while (($1)[0].sub <= ($3) && ($1)[0].map[($1)[0].sub])
      (($1)[0].sub)++;
    while (($1)[0].s[st+threadID] <= ($3) && 
           ($1)[0].map[($1)[0].s[st_threadID]])
      (($1)[0].s[st_threadID])++;
    ST_LOG(ST_GS_EXIT, lockAddr)
  } else {
    $2 = -1;
    if ($1[0].count[0] < ($4 - 1)) {
      SYS_DELAY($1,0,0)
    } else {
      $1[0].sub = 0;
      for (ti = 0; ti < ($4); ti++) 
        ($1)[0].s[ti] = 0;
      for (ti = 0; ti <= ($3); ti++) 
        ($1)[0].map[ti] = 0;
    }
    ST_LOG(ST_GS_EXIT_LAST, lockAddr)
    SYS_CONTINUE($1,0,0)
  }
  SYS_MEXIT($1,0)
  AUG_ON
}')

define(ADEC, `DECVAR($1,1,1,`int pgdone, pbdone;')')

define(AINIT, 
`{
  AUG_OFF
  SYS_MONINIT($1,1,1)
  $1[0].pgdone = $1[0].pbdone = 0;
  AUG_ON
}')

/* aSKFOR(name, 0success/1exhaust/-1prog_end/nprob_end, P, getProb, <reset>) */
define(ASKFOR, 
`{
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[0].lock);
  ST_LOG(ST_AS_ENTER, lockAddr)
  SYS_MENTER($1,0)
  if (($1[0].pgdone == 0) && ($1[0].pbdone != 0)) {
    if ($1[0].count[0] < ($3 - 1)) {
      SYS_DELAY($1,0,0)
    }
    ST_LOG(ST_AS_PROBDONE, lockAddr)
  } else {
    $2 = -2;
    while (($1[0].pgdone == 0) && ($1[0].pbdone == 0)) {
      $4
      if ($2 == 0) {
	ST_LOG(ST_AS_GOTTASK, lockAddr)
        SYS_CONTINUE($1,0,0)
      } else {
        if ($1[0].count[0] == ($3 - 1)) {
          $1[0].pbdone = 1;
        } else {
          SYS_DELAY($1,0,0)
	  ST_LOG(ST_AS_WORKWAIT, lockAddr)
        }
      }
    }
  }
  if ($1[0].pgdone != 0) {
    $2 = -1;
    ST_LOG(ST_AS_PROGDONE, lockAddr)
    SYS_CONTINUE($1,0,0)
  } else {
    $2 = $1[0].pbdone;
    if ($1[0].count[0] == 0) {
      $5
      $1[0].pbdone = 0;
    }
    ST_LOG(ST_AS_RESET, lockAddr)
    SYS_CONTINUE($1,0,0)
  }
  SYS_MEXIT($1,0)
  AUG_ON
}')

define(PROBEND, 
`{
  AUG_OFF
  SYS_MENTER($1,0)
  $1[0].pbdone = $2;
  SYS_MEXIT($1,0)
  AUG_ON
}')

define(PROGEND, 
`{
  AUG_OFF
  SYS_MENTER($1,0)
  $1[0].pgdone = 1;
  MAIN_END
  SYS_CONTINUE($1,0,0)
  SYS_MEXIT($1,0)
  AUG_ON
}')

define(LOCKDEC, `DECVAR($1,0,1)')
define(NLOCKDEC, `LOCKDEC($1,$2,$3)')

define(LOCKINIT, 
`{
  AUG_OFF
  SYS_MONINIT($1,0,1)
  ST_INFO_INIT($1, ST_MUTEX, &($1[0].lock) )
  ST_LOG(ST_LOCK_INIT, (int *)&($1[0].lock))
  AUG_ON
}')
define(NLOCKINIT, `LOCKINIT($1)')

define(LOCK, 
`{
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[0].lock);
  ST_LOG(ST_LOCK_ENTER, lockAddr )
  SYS_MENTER($1,0)
  ST_LOG(ST_LOCK_EXIT, lockAddr )
  AUG_ON
}')
define(NLOCK, `LOCK($1)')

/* note, should log before exit to ensure lock addr expression valid */
define(UNLOCK, 
`{
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[0].lock);
  ST_LOG(ST_UNLOCK, lockAddr )
  SYS_MEXIT($1,0)
  AUG_ON
}')
define(NUNLOCK, `UNLOCK($1)')

define(ALOCKDEC, `DECVAR($1,0,$2)')

define(ALOCKINIT, 
`{
  int smacs_dum1;
  for (smacs_dum1=0; smacs_dum1 < $2; smacs_dum1++) {
    ST_INFO_INIT($1, ST_MUTEX_ARRAY, &($1[smacs_dum1].lock) )
    ST_LOG(ST_LOCK_INIT, (int *)&($1[smacs_dum1].lock))
  }
  SYS_MONINIT($1,0,$2)
}')

define(ALOCK, 
`{  
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[$2].lock) ;
  ST_LOG(ST_ALOCK_ENTER, lockAddr )
  SYS_MENTER($1,$2)
  ST_LOG(ST_ALOCK_EXIT, lockAddr )
  AUG_ON
}')

define(AULOCK, 
`{  
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[$2].lock);
  ST_LOG(ST_AULOCK, lockAddr )
  SYS_MEXIT($1,$2)
  AUG_ON
}')

define(PAUSEDEC, `DECVAR($1,2,ifelse($2,,1,$2),int flag;)')

define(PAUSEINIT,
`{
  int p_dummy;
  AUG_OFF
  for (p_dummy = 0; (p_dummy < ifelse($2,,1,$2)); p_dummy++)
    $1[p_dummy].flag = 0;
  SYS_MONINIT($1,2,ifelse($2,,1,$2))
  AUG_ON
}')

define(CLEARPAUSE,
`{
  register int *lockAddr;

  AUG_OFF
  lockAddr = (int *)&($1[ifelse($2,,0,$2)].lock);
  ST_LOG(ST_EVENT_ENTER, lockAddr )
  SYS_MENTER($1,ifelse($2,,0,$2))
  $1[ifelse($2,,0,$2)].flag = 0;
  SYS_CONTINUE($1,0,ifelse($2,,0,$2))
  SYS_MEXIT($1,ifelse($2,,0,$2))
  ST_LOG(ST_EVENT_EXIT, lockAddr)
  AUG_ON
}')

define(SETPAUSE,
`{
  register int *lockAddr;

  AUG_OFF
  lockAddr = (int *)&($1[ifelse($2,,0,$2)].lock);
  ST_LOG(ST_EVENT_ENTER, lockAddr )
  SYS_MENTER($1,ifelse($2,,0,$2))
  $1[ifelse($2,,0,$2)].flag = 1;
  SYS_CONTINUE($1,0,ifelse($2,,0,$2))
  SYS_MEXIT($1,ifelse($2,,0,$2))
  ST_LOG(ST_EVENT_EXIT, lockAddr)
  AUG_ON
}')

define(EVENT,
`{
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[ifelse($2,,0,$2)].lock);
  ST_LOG(ST_EVENT_ENTER, lockAddr )
  SYS_MENTER($1,ifelse($2,,0,$2))
  if ($1[ifelse($2,,0,$2)].flag) {
    SYS_DELAY($1,0,ifelse($2,,0,$2))
  }
  $1[ifelse($2,,0,$2)].flag = 1;
  SYS_CONTINUE($1,1,ifelse($2,,0,$2))
  SYS_MEXIT($1,ifelse($2,,0,$2))
  ST_LOG(ST_EVENT_EXIT, lockAddr)
  AUG_ON
}')

define(WAITPAUSE,
`{
  register int *lockAddr;

  AUG_OFF
  lockAddr = (int *)&($1[ifelse($2,,0,$2)].lock);
  ST_LOG(ST_PAUSE_ENTER,lockAddr)
  SYS_MENTER($1,ifelse($2,,0,$2))
  if (!$1[ifelse($2,,0,$2)].flag) {
    SYS_DELAY($1,0,ifelse($2,,0,$2))
  }
  SYS_CONTINUE($1,0,ifelse($2,,0,$2))
  SYS_MEXIT($1,ifelse($2,,0,$2))
  ST_LOG(ST_PAUSE_EXIT,lockAddr)
  AUG_ON
}')

define(PAUSE,
`{
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[ifelse($2,,0,$2)].lock);
  ST_LOG(ST_PAUSE_ENTER, lockAddr )
  SYS_MENTER($1,ifelse($2,,0,$2))
  if (!$1[ifelse($2,,0,$2)].flag) {
    SYS_DELAY($1,1,ifelse($2,,0,$2))
  }
  $1[ifelse($2,,0,$2)].flag = 0;
  SYS_CONTINUE($1,0,ifelse($2,,0,$2))
  SYS_MEXIT($1,ifelse($2,,0,$2))
  ST_LOG(ST_PAUSE_EXIT, lockAddr )
  AUG_ON
}')

define(SRDEC, `DECVAR($1,2,ifelse($2,,1,$2),int flag;)')

define(SRINIT,
`{
  int s_dummy;
  AUG_OFF
  for (s_dummy = 0; (s_dummy < ifelse($2,,1,$2)); s_dummy++)
    $1[s_dummy].flag = 0;
  SYS_MONINIT($1,2,ifelse($2,,1,$2))
  AUG_ON
}')

define(SEND,
`{
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[ifelse($3,,0,$3)].lock);
  ST_LOG(ST_SEND_ENTER, lockAddr )
  SYS_MENTER($1,ifelse($3,,0,$3))
  if ($1[ifelse($3,,0,$3)].flag) {
    SYS_DELAY($1,0,ifelse($3,,0,$3))
  }
  $2
  $1[ifelse($3,,0,$3)].flag = 1;
  SYS_CONTINUE($1,1,ifelse($3,,0,$3))
  SYS_MEXIT($1,ifelse($3,,0,$3))
  ST_LOG(ST_SEND_EXIT, lockAddr)
  AUG_ON
}')

define(RECEIVE,
`{
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[ifelse($3,,0,$3)].lock);
  ST_LOG(ST_RECEIVE_ENTER, lockAddr )
  SYS_MENTER($1,ifelse($3,,0,$3))
  if (!$1[ifelse($3,,0,$3)].flag) {
    SYS_DELAY($1,1,ifelse($3,,0,$3))
  }
  $2
  $1[ifelse($3,,0,$3)].flag = 0;
  SYS_CONTINUE($1,0,ifelse($3,,0,$3))
  SYS_MEXIT($1,ifelse($3,,0,$3))
  ST_LOG(ST_RECEIVE_EXIT, lockAddr)
  AUG_ON
}')

define(HSEND,
`{
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[ifelse($3,,0,$3)].lock);
  ST_LOG(ST_HSEND_ENTER, lockAddr)
  SYS_MENTER($1,ifelse($4,,0,$4))
  if ($1[ifelse($4,,0,$4)].flag) {
    SYS_DELAY($1,0,ifelse($4,,0,$4))
  }
  $3
  $1[ifelse($4,,0,$4)].flag = $2;
  SYS_CONTINUE($1,1,ifelse($4,,0,$4))
  SYS_MEXIT($1,ifelse($4,,0,$4))
  ST_LOG(ST_HSEND_EXIT, lockAddr)
  AUG_ON
}')

define(HRECEIVE,
`{
  register int *lockAddr;
  AUG_OFF
  lockAddr = (int *)&($1[ifelse($3,,0,$3)].lock);
  ST_LOG(ST_HRECEIVE_ENTER, lockAddr )
  SYS_MENTER($1,ifelse($4,,0,$4))
  while ((!($1[ifelse($4,,0,$4)].flag)) ||
               ($1[ifelse($4,,0,$4)].flag == $2)) {
    SYS_DELAY($1,1,ifelse($4,,0,$4))
  }
  $3
  $1[ifelse($4,,0,$4)].flag = 0;
  SYS_CONTINUE($1,0,ifelse($4,,0,$4))
  SYS_MEXIT($1,ifelse($4,,0,$4))
  ST_LOG(ST_HRECEIVE_EXIT, lockAddr ) 
  AUG_ON
}')

define(DYNMASK, `0xffff')

define(TASKDEC, `DECTVAR($1)')

define(TASKINIT,
`{
  AUG_OFF
  if (spy_gm->taskTblIndex < MAXTASKS) {
    (spy_gm->taskTbl[spy_gm->taskTblIndex]).name = "$1";
    $1[0].addr = (int *) (spy_gm->taskTblIndex << 16);
    ++(spy_gm->taskTblIndex);
  } else {
    fprintf(stderr,"Too many tasks\n"); exit(-2);
  }
  ST_LOG(ST_TASK_INIT, (char *) $1[0].addr)
  AUG_ON
}')

define(BEGINTASK,
`{
  AUG_OFF
  ST_LOG(ST_BEGINTASK, ((int) $1[0].addr | (($2) & DYNMASK)))
  AUG_ON
}')

define(ENDTASK,
`{
  AUG_OFF
  ST_LOG(ST_ENDTASK, ((int) $1[0].addr | (($2) & DYNMASK)))
  AUG_ON
}')

divert(0)
