
\documentstyle[11pt]{article}

%---- Set out some layout parameters.
\setlength{\textheight}{9true in}
\setlength{\textwidth}{6.25true in}
\setlength{\topmargin}{-.43true in}
\setlength{\headheight}{.17true in}
\setlength{\headsep}{.25true in}
\setlength{\footheight}{.17true in}
\setlength{\footskip}{.42true in}
\setlength{\topskip}{12pt}
\setlength{\parskip}{4 mm}
\setlength{\parindent}{9 mm}
\setlength{\oddsidemargin}{0.25true in}
\if@twoside\setlength{\evensidemargin}{0true in}
	\else\setlength{\evensidemargin}{0.25true in}\fi
%----

\input{../../Research/Papers/idrawinclude}

\begin{document}

\begin{center}
{\LARGE Application programming with Quarks}

\vspace*{10 mm}

{\bf Dilip Khandekar} \\
\vspace*{5 mm}
\begin{em}
Computer Systems Laboratory \\
Department of Computer Science \\
University of Utah \\
Salt Lake City, UT~84112
\end{em}

\end{center}

\def\mysec#1{{\section{#1}\vspace*{-7 mm}}}
\def\mysubsec#1{{\subsection{#1}\vspace*{-7 mm}}}

\mysec{Introduction}
 
Quarks is a portable Distributed Shared Memory system on Unix. 
The system is used to write shared memory parallel programs
on distributed workstations. This document describes the
interface and explains how to use the system to write application
programs or to port existing shared memory parallel programs to run on
Quarks. 

\mysec{Shared memory}
 
The parallel programs in Quarks are composed of components running on
different workstations cooperating to solve a problem. The
communication between the components is through shared memory.
The memory model that Quarks provides for shared memory is a
release consistent one, hence the application programs must use
synchronization primitives to ensure correctness. Quarks can be built
to use different coherency protocols, for example write update
protocol, write invalidate protocol etc. 

A shared region has to be created using Qk\_create\_region() before it
can be used. Once a region has been created by a thread, other threads
can open it using Qk\_open\_region(). Any thread can create a region,
and any number of threads can subsequently open it. When a thread
forks child threads, all the regions created or opened by the parent
are also opened by the children as part of the fork semantics.

Quarks assumes a shared memory server running at a well known machine
which takes care of allocating and deallocating regions and 
synchronization primitives.

\mysec{Synchronization} 

Quarks provides three synchronization primitives {\em locks}, {\em
barriers} and {\em condition variables} for the application programs.
The primitives have to be allocated by the master process before
forking slave threads. 

Before entering a critical section, the program can acquire the lock
using Qk\_acquire(). The lock can be released by Qk\_release(). 
Program components can synchronize at a barrier by
Qk\_wait\_barrier().
Threads can wait on a condition using Qk\_wait\_condition(),
and be woken up by
Qk\_signal() or Qk\_broadcast() on the condition. Locks are implemented using
a distributed queue based algorithm, while the barrier and condition
variables are handled in a centralized fashion by the server. 

\mysec{ Programming model}

The programming model provided by Quarks is dictated by the region
open and close semantics. In an environment akin to that assumed by
SPLASH\cite{splash} programs, a master thread starts off first,
creating the required number of regions and initializing the shared
data. It also allocates all synchronization primitives. Then it forks
the child threads, which causes the regions to be opened and
synchronization primitives to be allocated at the child threads.
The parent and the child threads can share the data in the regions
and perform the computation. At the end of the computation cycle, the
child threads communicate their termination to the parent, which waits
for all the threads to terminate and then itself terminates. Although 
this fork-join cycle can be iterated as many number of times as
required, the initiation and termination of child threads is so heavy
weight that each computation has to be considerably coarse grained to
be effective. 

The semantics for fork as described above differs from that of Unix
fork. Unix fork assums that all the data, global as well as local,
shared and non shared, is copied to the child thread at the time of
fork. On the other hand, Quarks fork copies only the data in the shared
memory regions, so global unshared data is not initialized at the
child threads. It is the responsibility of the programmer to make sure
that any global unshared data at the slaves is properly initialized.
Step 2 of the skeleton program given below is a way to do that. 

The reason that Quarks cannot provide Unix fork semantics is that the
fork is across machine boundaries. Copying the whole data segment does
not help because that causes the Quarks internal data structures also
to get copied. These data structures are unique for a node in the
distributed application program, hence copying them will result in
incorrect behaviour. There needs to be a way to distinguish global
unshared data of application from library data, and to copy only the
former. We do not have a simple and portable solution yet, although we
are investigating a number of possible ways to make Quarks fork
semantics closer to Unix fork semantics. 

Because of the difference in fork semantics, Splash programs have to
be modified in order to port to Quarks. Appendix I discusses the
modifications needed to port Splash programs, using mp3d as an
example. 

\mysec{ Writing programs}

The structure of the function {\bf main()} of a Quarks application looks
as follows. Please note that this is akin to master-slave programming 
model as assumed by SPLASH programs, in which master initializes data
and forks slaves and finally waits for all slave threads to terminate.
Other programming models are very much possible. 


\begin{verbatim}
main()
{
    Qk_initialize();                                     /* step 1 */

    <application program initialization, required by   /* step 2 */
    all the processes (master as well as slaves)>

    if (Qkmaster)                               /* step 3a */
        <allocate and initialize shared memory regions and synch  
         primitives>

    if (Qkchild) return;	                       /* step 3b */

    <fork remote threads to run the computation function F>    /* step 4 */

    <invoke the computation function F (master executes this)> /* step 5 */

    <wait for all the slave threads to terminate>      /* step 6 */

    <print results, stats etc>                         /* step 7 */
}
\end{verbatim}

Each Quarks process starts with initializing the internal data
structures of Quarks, which is done by Qk\_initialize(). This is followed
by code that is to be executed by all the threads. For example,
parsing command line arguments, reading input files, etc. While
porting existing shared memory programs, care should be taken to
qualify the code to be executed only by the master with an 
``if (Qkmaster)'' conditional. Qkmaster and Qkchild are Quarks defined
variables which are initialized according to the master or slave
status of the node. For example, some SPLASH
programs initialize shared memory regions along with reading input.
Although, input is read by master as well as slave threads, shared
memory is initialized only by the master, hence the need for the
``if'' conditional. Porting Splash programs is discussed in greater
detail in Appendix I.
After the initialization, slave threads must return from {\bf main()}, while
the master can continue to allocate shared regions, synch primitives
etc., and finally fork remote threads. 

As part of step 1, the master process starts processes at remote hosts
using rsh. A command line argument passed to the executable denotes
the processes as slaves. Both the master and the slaves execute step
2. Step 3a is executed by the master only, while the slave returns
from main by executing step 3b. All the subsequent steps are executed
by the master. Of course, as a result of step 4, the slaves execute
computation function F. 

After termination of the computation, the master waits for all the
forked threads to terminate, prints results and statistics and exits.

\mysec{ Running programs}

To run an application program on Quarks requires a little bit of
preparation. The shared memory server has to be running on a well
known machine (say A). This machine name must be specified as a
command line parameter as discussed in the next section. 
The names of all the machines that the
user wants slave threads to run must be specified in file
{\bf Qk.hosts}. Each line in the file specifies a machine name. A \#
in the column in a line is taken as a comment and the line is ignored.
The application program is started as a master process,
which in turn starts processes at the specified hosts. Quarks creates
xterm windows to handle input and output of all the processes. The
xterms are displayed on the host specified by the DISPLAY environment
variable. 

The appearance of the xterms can be controlled by an X
resource file for quarks, called {\bf Qk.display}. The user can
specify all or some of the following. The width, height and text font
for the xterms, their horizontal and vertical displacements with
respect to each other and number of xterms in a column. A sample
Qk.display file in src directory will make the format clear.

\mysubsec{Quarks command line parameters}

Command line arguments can be supplied to Quarks by adding ``-~-'' to 
application program command line arguments, followed by
Quarks arguments. Currently the following arguments are recognized by
Quarks.

\hspace*{-10 mm} {\bf -nox}: supresses the display of xterms.
By default the xterms are displayed. 

\hspace*{-10 mm} {\bf -g}: starts the slave processes under gdb. 

\hspace*{-10 mm} {\bf -n <num>}: specifies the number of processors 
used to run the
application. Quarks creates only that many xterms as are required, if
more than {\em num} hosts are specified in Qk.hosts. In case less
hosts are specified, Quarks uses them in a round robin fashion to
assign working threads and create xterms. 

\hspace*{-10 mm} {\bf -s <hostname>}: specifies the hostname of the
shared memory server. If this parameter is absent, Quarks prompts the
user to specify the server host name. 

\hspace*{-10 mm} {\bf -m}: By default, a node with nodeid 1 is assumed
to be the master, since the server allocates nodeids linearly.
However, it is possible that the first nodeid allocated to an
application by the server is greater than 1, due to another
application which is running under the same server. In that case, the
user can specify the initiating node to be the master with this
parameter.

\hspace*{-10 mm} {\bf -c}: This should be the last of the command line
arguments. It specifies that the node is a child node. Usually this
argument is appended to the exitsing command line parameters by the
master when it invokes the child process using rsh. The users need to
specify this parameter only if they are starting the child processes
under gdb. 

\mysec{Function reference}

\setlength{\parindent}{0 cm}
{\bf void Qk\_initialize() } \\
This function initializes the internal data structures of Quarks. This
should be the first function to be called by the master as well as
slave processes. 

{\bf int       Qk\_fork(void* func)} \\
Creates a thread on a remote processor and executes
function {\em func} on that thread. Makes sure that the
state related to allocated shared memory regions
and synchronization primitives is communicated to the remote 
thread. In other words, the shared memory regions are copied to the
forked threads. As an optimization, the pages are not
actually copied as such. The page table entries at the remote
process are set up such that the process faults on a page reference
and the page is copied at that point. The semantics of Qk\_fork is
different than that of Unix fork, because the latter guarantees that
the entire data segment, which includes variables declared global but
not part of shared memory regions, are also copied. Splash programs
assume Unix fork semantics, hence they need to be modified to
accomodate Quarks fork semantics. Fortunately, the application
program initialization, depicted as step 2 of the skeleton main()
given above, takes care of correct initialization of such variables in
most Splash programs. 

{\bf unsigned long Qk\_wait\_for\_threads() } \\
The master process invokes this function. It waits
until {\bf all} child threads created by Qk\_fork terminate.

{\bf Id    Qk\_newlock()} \\
Allocates a new lock and returns the ID to that lock. This function
should be invoked by the master, before forking the slaves. The slaves
can directly use the ID. 

{\bf void      Qk\_acquire(Id lockid)} \\
 Acquires the lock given by {\em lockid}. The thread 
 invoking this function blocks until the lock is 
 acquired. Since Quarks uses queue based locks, a process is
guaranteed to get the lock at some point. 

{\bf void      Qk\_release(Id lockid)} \\
Releases the lock. The thread invoking this function
must be the holder of the lock.

{\bf Id Qk\_newbarrier()} \\
Allocates a new barrier and returns the ID to it. This function should
be invoked by the master, before forking the slaves. The slaves can
directly use the ID. 

{\bf void      Qk\_wait\_barrier(Id barrierid, int num\_crossers) }\\
 Blocks the thread invoking this function until 
 {\em num\_crossers} threads, including this one, have
 arrived at the barrier. {\em num\_crossers} can not be
 greater than the total number of processors 
 cooperating in the application program.

{\bf Id Qk\_newcondition() }\\
Allocates a new condition variable and returns its ID. This function
should be invoked by the master, before forking the slaves. The slaves
can directly use the ID.

{\bf void  Qk\_wait\_condition(Id condid, Id lockid)} \\
Waits for the condition denoted by condid to be true.
If lockid is non zero, the lock represented by lockid
is released while the thread waits. The lock id 
reacquired when the thread resumes. If lockid is 0, no
lock action is taken.

{bf void  Qk\_signal(Id condid)} \\
Makes the condition condid true. Also, wakes up one thread
waiting on the condition.

{\bf void Qk\_broadcast(Id condid)} \\
Makes the condition true and wakes up {\bf all} the thread 
waiting on it.

{\bf void Qk\_create\_region(Id regionid, int size, unsigned long *mem\_ptr)} \\
Allocates a shared memory region with name regionid. If regionid is
0, then the server allocates a name for the region. The server creates
a region of atleast {\em size} bytes. A region is allocated page
aligned. {\em mem\_ptr} is the address of the variable to which the
address of the region is assigned. Following is an example usage: \\

\begin{verbatim}
struct shared_mem *gl;

Qk_create_region(0, SIZE, &gl);
\end{verbatim}

{\em gl} will contain the address of the base of the shared region.
The address of {\em gl} is recorded in Quarks internal data structures
and is communicated at the time of fork so that the child threads can
initialize the variable {\em gl} in their address space. 

{\bf unsigned  long Qk\_current\_time() }\\
Returns the current time maintained by the Quarks clock.
Time returned is micro-seconds since start of program.

{\Large {\bf Appendix I: Porting Splash programs to Quarks}}\\

\setlength{\parindent}{9 mm}
\vspace*{-7 mm}
As mentioned above, the semantics of fork assumed by Splash programs
is different than that provided by Quarks. Therefore, Splash programs
have to be modified to be ported to Quarks. Splash programs assume
that the master starts first, and executes the initialization code 
in {\bf main}
until the point when it forks slave threads. The fork results in the
data, unshared as well as shared, of the master to be copied to the
slaves. Thereafter the threads run independently, with only the data
in allocated shared regions being actually shared. 

Quarks starts {\bf main} in both the master as well as the slaves. In
order to initialize the global unshared variables, the slave
threads also have to execute the initialization code. But since
allocation of shared memory and synchronization primitives should be
done only by the master, and it is part of initialization code,
the macros G\_MALLOC, LOCKINIT, BARINIT etc.
must be qualified by a {\bf if (Qkmaster)} conditional.
Moreover, initialization of shared memory should be executed only
by the master. For example, the allocation of {\em Global} and {\em
Particles} shared memory regions in {\bf prepare\_multi} function
of mp3d is executed only by the master. Also, function {\bf
fill\_space}, which initializes the {\em Particles} shared region, is 
executed only by the master. 

At a few places in Splash programs, an unshared variable is initialized using
a value of shared data. Since shared data is not initialized in slave
threads, a new global variable has to be introduced, which is a
``shadow'' of the shared data, and is initialized by both the master
as well as the slaves. The code executed by the slave threads use this
shadow variable to initialize the unshared variable. 
An example is the Q\_global\_num\_mol variable
introduced in {\bf get\_user\_info} function. 

After initialization, the slave threads must return from {\bf main}. The
statement {\bf if (Qkchild) return;} is the point where
the slave threads return from {\bf main}. Care should be taken to make sure
that all initialization of unshared data is done before the child
returns. In other words, code following this statement
should only contain initialization of shared data or data required
only by the master, forking of slave threads, etc.

\mysec{Copyright and bug reports}

Quarks is Copyright (c) 1995 of the {\em University of Utah} and {\em
Computer Systems Laboratory (CSL)}. Please consult the terms and
conditions before using, copying, modifying and distributing the
software. 

Please feel free to contact quarks-bugs@cs.utah.edu for further
help or clarification.  All bug reports, suggestions, etc should be
directed to the above address.  See the TODO file for areas of work.
Of course, any contributions in terms of porting Quarks to other
platforms, enhancing it etc, will be greatly appreciated and duly
acknowledged. 



\begin{thebibliography}{99}

\bibitem{splash}
Jaswinder Pal Singh, Wolf-Dietrich Weber and Anoop Gupta. SPLASH:
Stanford Parallel Applications for Shared-Memory. {\em Computer
Systems Laboratory, Stanford University Tech report}.

\end{thebibliography}
\end{document}

