diff -r Boundary_Cond/boundary_cond.c ../ICE_MM/Boundary_Cond/boundary_cond.c
427c427,428
<             ...)                    /* used to designate whether        (INPUT) */
---
>     double  ****data_CC,                /* cell-centered data array         (IN/OUT)*/
>     int     var,...)                    /* used to designate whether        (INPUT) */
432,434c433
<     int     m,  
<             var,                        /* used to designate whether the    */
<                                         /* input array is UVEL, TEMP....    */               
---
>     int     m,               
436d434
<     double ****data_CC;                 /* cell-centered data array         */
596c594,599
<          ...)          
---
>     double ****data_CC,                 /* cell-centered data array         */
>     int     var,                        /* used to designate whether        */
>                                         /* the input array is UVEL,TEMP.... */
>     double ******data_FC, ...)          /* face-centered data               (INPUT) */
>                                         /*     (x,y,z,face, material)       */              
>                        
600,603c603
<            array,                       /* array number                     */
<            var;
<     double ****data_CC,
<            ******data_FC;
---
>             array;                      /* array number                     */
672d671
<                                 delX,           delY,           delZ,
674c673
<                                 BC_types,       BC_Values,      BC_float_or_fixed,     
---
>                                 BC_types,       BC_float_or_fixed,     
828c827
<                             data_CC[m][i][j][k] = BC_Values[wall][var][m];
---
>                             data_CC[i][j][k][m] = BC_Values[wall][var][m];
1064c1063
<                     data_CC[m][i][j][k] = data_CC[m][i+1][j][k]
---
>                     data_CC[i][j][k][m] = data_CC[i+1][j][k][m]
1069c1068
<                     data_CC[m][i][j][k] = data_CC[m][i-1][j][k]
---
>                     data_CC[i][j][k][m] = data_CC[i-1][j][k][m]
1074c1073
<                     data_CC[m][i][j][k] = data_CC[m][i][j-1][k]
---
>                     data_CC[i][j][k][m] = data_CC[i][j-1][k][m]
1079c1078
<                     data_CC[m][i][j][k] = data_CC[m][i][j+1][k]
---
>                     data_CC[i][j][k][m] = data_CC[i][j+1][k][m]
1207c1206
<                                  data_CC[m][i][j][k] = data_CC[m][xHiLimit][j][k];
---
>                                  data_CC[i][j][k][m] = data_CC[xHiLimit][j][k][m];
1211c1210
<                                  data_CC[m][i][j][k] = data_CC[m][xLoLimit][j][k];
---
>                                  data_CC[i][j][k][m] = data_CC[xLoLimit][j][k][m];
1215c1214
<                                  data_CC[m][i][j][k] = data_CC[m][i][yLoLimit][k];
---
>                                  data_CC[i][j][k][m] = data_CC[i][yLoLimit][k][m];
1219c1218
<                                  data_CC[m][i][j][k] = data_CC[m][i][yHiLimit][k];
---
>                                  data_CC[i][j][k][m] = data_CC[i][yHiLimit][k][m];
1311c1310
<         data_CC[m][i][j][k]     = ( data_CC[m][i][j-1][k] + data_CC[m][i+1][j][k]) /2.0;
---
>         data_CC[i][j][k][m]     = ( data_CC[i][j-1][k][m] + data_CC[i+1][j][k][m]) /2.0;
1320c1319
<         data_CC[m][i][j][k]     = ( data_CC[m][i][j-1][k] + data_CC[m][i-1][j][k]) /2.0;
---
>         data_CC[i][j][k][m]     = ( data_CC[i][j-1][k][m] + data_CC[i-1][j][k][m]) /2.0;
1331c1330
<         data_CC[m][i][j][k]     = ( data_CC[m][i][j+1][k] + data_CC[m][i-1][j][k]) /2.0;
---
>         data_CC[i][j][k][m]     = ( data_CC[i][j+1][k][m] + data_CC[i-1][j][k][m]) /2.0;
1340c1339
<         data_CC[m][i][j][k]     = ( data_CC[m][i][j+1][k] + data_CC[m][i+1][j][k]) /2.0;
---
>         data_CC[i][j][k][m]     = ( data_CC[i][j+1][k][m] + data_CC[i+1][j][k][m]) /2.0;
Only in Boundary_Cond/: boundary_cond.o
diff -r Boundary_Cond/boundary_cond_FC.c ../ICE_MM/Boundary_Cond/boundary_cond_FC.c
43,45d42
<     double  delX,                       /* cell size in x direction         (INPUT) */
<     double  delY,                       /* cell size in y direction         (INPUT) */
<     double  delZ,                       /* cell size in z direction         (INPUT) */
52,53d48
<     double  ***BC_Values,               /* BC values BC_values[wall][var][m](INPUT)*/
<                                         
62c57
<             wall,       cell,    
---
>             wall,      
67c62
<             faceLo,     faceHi,
---
>             faceLo,     faceHi, 
126,129d120
<                         
<                         
< #if 0                        
< /*`==========TESTING==========*/ 
141,165c132
<                             *data_FC[i][j][k][f][m] = data_CC[m][i][j][k];
<                         }
<                     }
<                 }
<             }
<  /*==========TESTING==========`*/    
<  #endif                    
< 
<             /*__________________________________
<             *  TOP of domain
<             *___________________________________*/                        
<             if (wall == TOP) 
<             {                   
<                 for ( k = zLo; k <= zHi; k++)
<                 {
<                     for ( j = yLo; j <= yHi; j++)
<                     { 
<                         cell = j-1; 
<                         for ( i = xLo; i <= xHi; i++)
<                         {
<                             *data_FC[i][j][k][TOP][m] = *data_FC[i][cell][k][TOP][m]
<                             + BC_Values[wall][var][m] * delY;
<                             
<                             /* *data_FC[i][j][k][TOP][m] = data_CC[m][i][j][k]; */
<                             /* *data_FC[i][j][k][BOTTOM][m] = data_CC[m][i][j][k]; */
---
>                             *data_FC[i][j][k][f][m] = data_CC[i][j][k][m];
169,309c136
<             }
<             
<             /*__________________________________
<             *  BOTTOM of domain
<             *___________________________________*/                        
<             if (wall == BOTTOM) 
<             {                   
<                     
<                 for ( k = zLo; k <= zHi; k++)
<                 {
<                     for ( j = yLo; j <= yHi; j++)
<                     { 
<                         cell = j+1;
<                         for ( i = xLo; i <= xHi; i++)
<                         {
<                             *data_FC[i][j][k][BOTTOM][m]    = *data_FC[i][cell][k][BOTTOM][m]
<                             - BC_Values[wall][var][m] * delY;
<                             
< #if 0                            
< /*`==========TESTING==========*/ 
<                         for(f = faceLo ; f <= faceHi; f ++)
<                         {            
<                             *data_FC[i][j][k][f][m] = data_CC[m][i][j][k];
<                         }
<  /*==========TESTING==========`*/
< #endif
<                         }
<                     }
<                 }
<             }
<             
<             /*__________________________________
<             *  RIGHT of domain
<             *___________________________________*/                        
<             if (wall == RIGHT) 
<             {                     
<                 for ( k = zLo; k <= zHi; k++)
<                 {
<                     for ( j = yLo; j <= yHi; j++)
<                     { 
<                         for ( i = xLo; i <= xHi; i++)
<                         {
<                             cell = i-1;
<                             *data_FC[i][j][k][RIGHT][m] = *data_FC[cell][j][k][RIGHT][m]
<                             + BC_Values[wall][var][m] * delX;
<                             /* *data_FC[i][j][k][TOP][m]   = *data_FC[cell][j][k][TOP][m]; */
< #if 0
< /*`==========TESTING==========*/ 
<                         for(f = faceLo ; f <= faceHi; f ++)
<                         {            
<                             *data_FC[i][j][k][f][m] = data_CC[m][i][j][k];
<                         }
<  /*==========TESTING==========`*/
< #endif
<                         }
<                     }
<                 }
<             }
<             
<             /*__________________________________
<             *  LEFT of domain
<             *___________________________________*/                        
<             if (wall == LEFT) 
<             {                      
<                 for ( k = zLo; k <= zHi; k++)
<                 {
<                     for ( j = yLo; j <= yHi; j++)
<                     { 
<                         for ( i = xLo; i <= xHi; i++)
<                         {
<                             cell = i+1;
<                             *data_FC[i][j][k][LEFT][m]  = *data_FC[cell][j][k][LEFT][m]
<                             - BC_Values[wall][var][m] * delX;
<                             /* *data_FC[i][j][k][TOP][m]   = *data_FC[cell][j][k][TOP][m]; */
< #if 0
< /*`==========TESTING==========*/ 
<                         for(f = faceLo ; f <= faceHi; f ++)
<                         {            
<                             *data_FC[i][j][k][f][m] = data_CC[m][i][j][k];
<                         }
<  /*==========TESTING==========`*/
< #endif 
<                         }
<                     }
<                 }
<             }
<             /*__________________________________
<             *  FR0NT of domain
<             *___________________________________*/                        
<             if (wall == FRONT) 
<             {       
<                 Message(1,"File: boundary_cond_FC","Function: set_Neumann_BC_FC",
<                 "Error: Need to test to make sure this is right");
<                          
<                 for ( k = zLo; k <= zHi; k++)
<                 {
<                     cell = k-1;
<                     for ( j = yLo; j <= yHi; j++)
<                     { 
<                         for ( i = xLo; i <= xHi; i++)
<                         {
<                             *data_FC[i][j][k][FRONT][m] = *data_FC[i][j][cell][FRONT][m]
<                             + BC_Values[wall][var][m] * delZ;
< #if 0
< /*`==========TESTING==========*/ 
<                         for(f = faceLo ; f <= faceHi; f ++)
<                         {            
<                             *data_FC[i][j][k][f][m] = data_CC[m][i][j][k];
<                         }
<  /*==========TESTING==========`*/
< #endif 
<                         }
<                     }
<                 }
<             }
<             /*__________________________________
<             *  FR0NT of domain
<             *___________________________________*/                        
<             if (wall == BACK) 
<             {          
<                 Message(1,"File: boundary_cond_FC","Function: set_Neumann_BC_FC",
<                 "Error: Need to test to make sure this is right");           
<                 for ( k = zLo; k <= zHi; k++)
<                 {
<                     cell = k+1;
<                     for ( j = yLo; j <= yHi; j++)
<                     { 
<                         for ( i = xLo; i <= xHi; i++)
<                         {
<                             *data_FC[i][j][k][BACK][m] = *data_FC[i][j][cell][BACK][m]
<                             - BC_Values[wall][var][m] * delZ;
< /*`==========TESTING==========*/ 
<                         for(f = faceLo ; f <= faceHi; f ++)
<                         {            
<                             *data_FC[i][j][k][f][m] = data_CC[m][i][j][k];
<                         }
<  /*==========TESTING==========`*/
<                         }
<                     }
<                 }
<             }            
---
>             } 
336d162
< /*`==========TESTING==========*/ 
343,345c169,171
<             *data_FC[i][j][k][BOTTOM][m] = data_CC[m][i][j][k];
<             *data_FC[i][j][k][LEFT][m]   = data_CC[m][i][j][k];
<        
---
>             *data_FC[i][j][k][BOTTOM][m] = data_CC[i][j][k][m];
>             *data_FC[i][j][k][LEFT][m]   = data_CC[i][j][k][m];
>             
348,349c174,175
<             *data_FC[i][j][k][TOP][m]    = data_CC[m][i][j][k];
<             *data_FC[i][j][k][LEFT][m]   = data_CC[m][i][j][k];
---
>             *data_FC[i][j][k][TOP][m]    = data_CC[i][j][k][m];
>             *data_FC[i][j][k][LEFT][m]   = data_CC[i][j][k][m];
353,354c179,180
<             *data_FC[i][j][k][TOP][m]    = data_CC[m][i][j][k];
<             *data_FC[i][j][k][RIGHT][m]  = data_CC[m][i][j][k];
---
>             *data_FC[i][j][k][TOP][m]    = data_CC[i][j][k][m];
>             *data_FC[i][j][k][RIGHT][m]  = data_CC[i][j][k][m];
358,359c184,185
<             *data_FC[i][j][k][BOTTOM][m] = data_CC[m][i][j][k];
<             *data_FC[i][j][k][RIGHT][m]  = data_CC[m][i][j][k];
---
>             *data_FC[i][j][k][BOTTOM][m] = data_CC[i][j][k][m];
>             *data_FC[i][j][k][RIGHT][m]  = data_CC[i][j][k][m];
362d187
<  /*==========TESTING==========`*/
598a424,708
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  /*______________________________________________________________________
>  *  Below is old code that I'm not ready to throwout
>  *_______________________________________________________________________*/
>  
>  
>  
>  
>  
>  
>  
>  #if 0      /*DONT COMPILE FOR NOW 12/4/99*/
>  /* 
>  ======================================================================*/
> #include <math.h>
> #include <assert.h>
> #include "switches.h"
> #include "parameters.h"
> #include "functionDeclare.h"
> #include "macros.h"
> /*
> set_Wall_BC_FC
> boundary_cond.c
>  Purpose:
>             This function sets the velocity boundary conditions along the walls
>             of the computational domain. For each wall the following is set
>     
>    Right Wall      uvel_FC[xHiLimit,j,k,RIGHT,m]   = 0
>                    vvel_FC(xHiLimit+1,j,k,TOP,m]   = -vvel_FC(xHiLimit,j,k,TOP,m]
>                    vvel_FC(xHiLimit+1,j,k,BOTTOM,m]= -vvel_FC(xHiLimit,j,k,BOTTOM,m]
> 
>    Left Wall       uvel_FC[xLoLimit,j,k,RIGHT,m]   = 0
>                    vvel_FC(xLoLimit-1,j,k,TOP,m]   = -vvel_FC(xLoLimit,j,k,TOP,m]
>                    vvel_FC(xLoLimit-1,j,k,BOTTOM,m]= -vvel_FC(xLoLimit,j,k,BOTTOM,m]
> 
>    BOTTOM Wall     vvel_FC[yLoLimit,j,k,BOTTOM,m]  = 0
>                    uvel_FC(i,yLoLimit-1,k,LEFT,m]  = -uvel_FC(i,yLoLimit,k,LEFT,m]
>                    uvel_FC(i,yLoLimit-1,k,RIGHT,m] = -uvel_FC(i,yLoLimit,k,RIGHT,m]
> 
>    TOP Wall        vvel_FC[yHiLimit,j,k,BOTTOM,m]  = 0
>                    uvel_FC(i,yHiLimit+1,k,LEFT,m]  = -uvel_FC(i,yHiLimit,k,LEFT,m]
>                    uvel_FC(i,yHiLimit+1,k,RIGHT,m] = -uvel_FC(i,yHiLimit,k,RIGHT,m]
> 
> References: 
>     This is from 
>     Bulgarelli, U., Casulli, V. and Greenspan, D., "Pressure Methods for the 
>     Numerical Solution of Free Surface Fluid Flows, Pineridge Press
>     (1984) pg 100
>     
>  History:
>     Version   Programmer         Date       Description
>     -------   ----------         ----       -----------
>        1.0     Todd Harman       08/22/99    
> 
>  ---------------------------------------------------------------------  */
>  
>  void set_Wall_BC_FC( 
>               
>         int     xLoLimit,               /* x-array lower limit              */
>         int     yLoLimit,               /* y-array lower limit              */
>         int     zLoLimit,               /* z-array lower limit              */
>         int     xHiLimit,               /* x-array upper limit              */
>         int     yHiLimit,               /* y-array upper limit              */
>         int     zHiLimit,               /* z-array upper limit              */
>         double  ******uvel_FC,          /* u-face-centered velocity         (IN/OUT)*/
>                                         /* uvel_FC(x,y,z,face)                      */
>         double  ******vvel_FC,          /*  v-face-centered velocity        (IN/OUT)*/
>                                         /* vvel_FC(x,y,z, face)                     */
>         double  ******wvel_FC,          /* w face-centered velocity         (IN/OUT)*/
>                                         /* wvel_FC(x,y,z,face)                      */
>  
>         int     ***BC_types,            /* defines which boundary conditions(INPUT) */
>                                         /* have been set on each wall       */
>         int     nMaterials )
> 
>  {
>     int     i,j,k,f,m,                  /* indices                           */
>             wall,       var,
>             xLo,        xHi, 
>             yLo,        yHi, 
>             zLo,        zHi,
>             wallLo,     wallHi,
>             faceLo,     faceHi,
>             should_I_leave;
> /*__________________________________
> * double check inputs
> *___________________________________*/
>     assert ( xLoLimit >= 0 && xHiLimit <= X_MAX_LIM);
>     assert ( yLoLimit >= 0 && yHiLimit <= Y_MAX_LIM);
>     assert ( zLoLimit >= 0 && zHiLimit <= Z_MAX_LIM);
> /*__________________________________
> *   Determine the looping indices
> *   for multidimensional problems
> *___________________________________*/
> #if (N_DIMENSIONS == 1) 
>         wallLo = LEFT;  wallHi = RIGHT;
>         faceLo = LEFT;  faceHi = RIGHT;
> #endif
> #if (N_DIMENSIONS == 2) 
>         wallLo = TOP;   wallHi = LEFT;
>         faceLo = TOP;   faceHi = LEFT;
> #endif
> #if (N_DIMENSIONS == 3) 
>         wallLo = TOP;   wallHi = BACK;
>         faceLo = TOP;   faceHi = BACK;
> #endif
> /*__________________________________
> *   Test to see if you should be in this function
> *___________________________________*/
>     should_I_leave = YES;
>     for(m = 1; m <= nMaterials; m++)
>     {    
>         for( wall = wallLo; wall <= wallHi; wall ++)
>         {
>             for (var = VEL_BC; var <= PRESS_BC; var ++)
>             {
>                 if(BC_types[wall][var][m] == WALL) should_I_leave = NO;
>             }
>         }
>     }
>     if (should_I_leave == YES) return;
> /*______________________________________________________________________
> *   Now loop over all of the walls and set the appropriate BC
> *   You need to find what the appropriate looping limits are for each 
> *   side of the computational domain
> *_______________________________________________________________________*/
>             
>     for( wall = wallLo; wall <= wallHi; wall ++)
>     {
> 
>        if( BC_types[wall][VEL_BC][m] == WALL)
>        {          
>             /*_________________________________
>             *   Define the corner of each wall
>             *   BE CAREFULL HERE NOT TO OVERLAP!
>             *   NEED TO ADD 3D.  Note this is different
>             *   from the upper and lower limits 
>             *   calculated in "find_loop_index_limits_at_domain_edges("
>             *___________________________________*/
>            if( wall == LEFT )
>            {
>                 f   = LEFT;
>                 xLo = xLoLimit;                xHi = xLoLimit;
>                 yLo = yLoLimit;                yHi = yHiLimit; 
>                 zLo = zLoLimit;                zHi = zHiLimit;
>             }
>            if( wall == RIGHT ) 
>            {    
>                 f   = RIGHT;
>                 xLo = xHiLimit;                xHi = xHiLimit;
>                 yLo = yLoLimit;                yHi = yHiLimit; 
>                 zLo = zLoLimit;                zHi = zHiLimit;
>             }
>            if( wall == TOP ) 
>            {
>                 f   = TOP;
>                 xLo = xLoLimit;                xHi = xHiLimit;
>                 yLo = yHiLimit;                yHi = yHiLimit; 
>                 zLo = zLoLimit;                zHi = zHiLimit;
>             }
>            if( wall == BOTTOM ) 
>            {
>                 f   = BOTTOM;
>                 xLo = xLoLimit;                xHi = xHiLimit;
>                 yLo = yLoLimit;                yHi = yLoLimit; 
>                 zLo = zLoLimit;                zHi = zHiLimit;
>            }
>            /*__________________________________
>            *   For each variable set the boundary condition
>            *   if appropriate
>            *___________________________________*/
>            for(m = 1; m <= nMaterials; m++)
>            {
>               for ( k = zLo; k <= zHi; k++)
>               {
>                   for ( j = yLo; j <= yHi; j++)
>                   {
>                       for ( i = xLo; i <= xHi; i++)
>                       {
>                            /*__________________________________
>                            *   RIGHT WALL
>                            *___________________________________*/
>                            if (f == RIGHT)
>                            { 
>                                *uvel_FC[xHi][j][k][f][m]       = 0.0;
>                                *vvel_FC[xHi+1][j][k][TOP][m]   = -*vvel_FC[xHi][j][k][TOP][m];
>                                *vvel_FC[xHi+1][j][k][BOTTOM][m]= -*vvel_FC[xHi][j][k][BOTTOM][m];
>                            }
>                            /*__________________________________
>                            *   LEFT WALL
>                            *___________________________________*/
>                            if (f == LEFT)
>                            { 
>                                *uvel_FC[xLo][j][k][f][m]       = 0.0;
>                                *vvel_FC[xLo-1][j][k][TOP][m]   = -*vvel_FC[xLo][j][k][TOP][m];
>                                *vvel_FC[xLo-1][j][k][BOTTOM][m]= -*vvel_FC[xLo][j][k][BOTTOM][m];
>                            }
>                            /*__________________________________
>                            *   BOTTOM WALL
>                            *___________________________________*/
>                             if (f == BOTTOM)
>                            { 
>                                *vvel_FC[i][yLo][k][f][m]       = 0.0;
>                                *uvel_FC[i][yLo-1][k][LEFT][m]  = -*uvel_FC[i][yLo][k][LEFT][m];
>                                *uvel_FC[i][yLo-1][k][RIGHT][m] = -*uvel_FC[i][yLo][k][RIGHT][m];
>                            }
>                            /*__________________________________
>                            *   TOP WALL
>                            *___________________________________*/
>                             if (f == TOP)
>                            { 
>                                *vvel_FC[i][yHi][k][f][m]       = 0.0;
>                                *uvel_FC[i][yHi+1][k][LEFT][m]  = -*uvel_FC[i][yHi][k][LEFT][m];
>                                *uvel_FC[i][yHi+1][k][RIGHT][m] = -*uvel_FC[i][yHi][k][RIGHT][m];
> 
>                                /*__________________________________
>                                *   HARDWIRED FOR DRIVEN CAVITY PROBLEM
>                                * where utop = 0.5
>                                *___________________________________*/
>                               /*  *uvel_FC[i][yHi+1][k][RIGHT][m]= 1.0 - *uvel_FC[i][yHi][k][RIGHT][m];
>                                *uvel_FC[i][yHi+1][k][LEFT][m]= 1.0 - *uvel_FC[i][yHi][k][LEFT][m];  */
>                            }
> 
> 
>                       }
>                   }
>               }
>            }
>        }
>     }
> 
> 
> /*______________________________________________________________________
> *   DEBUGGING INFORMATION
> *_______________________________________________________________________*/ 
> #if switchDebug_set_wall_BC_FC
>     fprintf(stderr,"****************************************************************************\n");
>     fprintf(stderr,"                        SET_WALL_BC_FC\n");
>     fprintf(stderr,"****************************************************************************\n");         
>          
>     printData_6d(       GC_LO(xLoLimit),     GC_LO(yLoLimit),       GC_LO(zLoLimit),
>                         GC_HI(xHiLimit),     (yHiLimit),       (zHiLimit),
>                         RIGHT,              LEFT,
>                         m,                  m,
>                        "set_Wall_BC_FC",     
>                        "Uvel_FC with ghost cells",           uvel_FC,        0);
> 
>     printData_6d(       GC_LO(xLoLimit),     GC_LO(yLoLimit),       GC_LO(zLoLimit),
>                         GC_HI(xHiLimit),     (yHiLimit),            (zHiLimit),
>                         TOP,                BOTTOM,
>                         m,                  m,
>                        "set_Wall_BC_FC",     
>                        "vvel_FC with ghost cells",           vvel_FC,        0);
> 
>                            
>     fprintf(stderr,"****************************************************************************\n");         
>     
>     fprintf(stderr,"press return to continue\n");
>     getchar();            
> #endif
> /*__________________________________
> *   Quite fullwarn remarks is a way that
> *   is compiler independent
> *___________________________________*/
>     faceHi = faceHi;                                faceLo = faceLo;
>     QUITE_FULLWARN(*wvel_FC[0][0][0][1][1]);
>  }
> #endif
Only in Boundary_Cond/: boundary_cond_FC.o
