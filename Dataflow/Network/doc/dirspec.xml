
<!--
  The contents of this file are subject to the University of Utah Public
  License (the "License"); you may not use this file except in compliance
  with the License.
  
  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations under
  the License.
  
  The Original Source Code is SCIRun, released March 12, 2001.
  
  The Original Source Code was developed by the University of Utah.
  Portions created by UNIVERSITY are Copyright (C) 2001, 1994 
  University of Utah. All Rights Reserved.
-->

<chapter>
  <title>Dataflow Development</title>

  <sect1>
    <para>
      This chapter describes dataflow programming in general, and provides
      specific details for dataflow programming within SCIRun.
    </para>
  </sect1>

  <sect1>
    <title>Introduction</title>

    <para>
      The goal of SCIRun is to provide a problem solving environment in which
      a scientist, with little programming experience, can easily 
      solve a problem using powerful tools such as parallel super computing
      for number crunching, and high performance graphics for interactive
      visualization.  SCIRun accomplishes this goal by employing a programming
      paradigm called <term>dataflow</term>.
    </para>

    <para>
      Dataflow programming essentially provides coarse grained, configurable
      algorithms that, when tied together, act as a program for
      solving a problem.  A dataflow programmer needs to know very little about
      how to program a parallel super computer, or how to use the latest
      graphics hardware to generate a visualization, in order to use those
      tools - all she needs to do is focus on the science behind the problem
      being solved.  
    </para>

    <para>
      In SCIRun the dataflow paradigm is manifested visually as a set of boxes,
      called modules, each of which contains a variety of pre-implemented
      algorithms.  The modules have data ports, both input and output, for
      accepting and relaying data.  The flow of data through the modules is 
      dictated by connections made between input and output ports: The output
      port of one module is connected to the input port of one or more other
      modules.  A series of connected modules is called a network, which can 
      be thought of as a program for solving a particular type of problem.
    </para>
    
    <para>
      There are several pre-implemented modules and ports in SCIRun that
      allow a dataflow network programmer to build networks that solve a
      variety of novel problems.  However, the the real power of SCIRun is in
      it's ability to be extended through the development of new modules and
      new ports which expand the number of types of solvable problems.
    </para>

    <para>
      The rest of this guide explains how to develop new SCIRun
      dataflow elements, and explains how to use powerful tools such
      as 3D widgets, threads, etc. in SCIRun.  Development within
      SCIRun requires a working knowledge of C++ programming, Unix
      file systems etc.  knowledge of Tcl/Tk scripting will be useful.
    </para>
  </sect1>

  <sect1>
    <title>Developing new SCIRun dataflow elements</title>

    <sect2>
      <title>Creating new modules</title>

      <para>
        From the most abstract perspective, a module is one or more
        algorithms that solves a single, specific and coarse grained, problem.
        For example, suppose you have a large list of english words that you
        want to sort.  There are several algorithms that you may employ to
        to solve this problem such as bubble sort, quick sort, etc.
        A module that also solves this problem, likely named Sort, would
        be a collection of one or more of these algorithms.
      </para>

      <para>
        On a more concrete level, a module is comparable
        to a function or procedure (of a high level text based
        programming language like C) that also implements one or more
        algorithms to solve a specific problem.  The prototype for
        such a function that solves the sort problem might look like this:
      </para>

      <computeroutput>

void Sort(string *words_to_sort, int alg_to_use);
      </computeroutput>

      <para>
        Where words_to_sort is a random , possibly large, list of words
        to be sorted (the data), and alg_to_use is a single integer (the
        control) which is used to select one of the implemented algorithms.
      </para>

      <para>
        The Sort module is similar to the Sort function in many ways:
        They both have input (data and control), they both have output,
        they both have a single point of entry for execution, and they
        can both be used modularly in any program.
        The ports of a module serve some of the same functions as the
        formal parameters to a function: they can accept and relay data
        and they enforce type matching.
        One important difference is that the Sort module seperates
        the mode for communicating inputs of different kinds, i.e. data
        is treated differently and seperately from control.
      </para>
    
      <para>
        On the lowest level a module is almost exactly like the function.
        The module is actually implemented as a C++ class with one member
        function named execute().  The execute member function is
        identical to the C function in many ways.  In fact, it is possible
        to cut the contents out of the C function and paste them into
        the execute function of the module and achieve the same 
        functionality, with one caveat: the module does not pass 
        data or control to the execute function through formal parameters,
        like the C function.  Instead, the execute function acquires the data
        and control by using additional function calls:
      </para>
    
      <computeroutput>

void Sort::execute() 
{
  string *words = get_data();    // get the data from the input port
  int alg       = get_control(); // get the control from the GUI

  //
  //  one can either paste the contents of the sort
  //  function here, or simply call it:
  //
  
  if (words) sort(words,alg);
	
  send_data(words);  // send the result to the output port
}
      </computeroutput>

      <para>
        So, a module is simply a C++ class, and in order to develop a new
        module, one simply needs to create a new class.  Creating a new module
        can be done semi-automatically using SCIRun's Module Wizard, or can
        be done by hand.  The Module Wizard will be discussed in greater detail
        later in this chapter.  Regardless of how the new module is created,
        there are some conventions that must be followed in order to have the
        new module be usable from within SCIRun, for example, the
        class needs to inherit from the Module base class, and it needs to
        implement a specific set of functions.  Let's build the Sort
        module by hand as an example.  By convention, a module is
        declared and defined in a single C++ file (.cc extension) with
        the base name of the module i.e. Sort will be completely
        implemented in the single file "Sort.cc".
      </para>

      <para>
        To get started, we need to declare a class that will
        become the Sort module:
      </para>

      <computeroutput>

#include &lt;Dataflow/Network/Module.h>     // module base class
#include &lt;Dataflow/Ports/WordListPort.h> // wordlist port classes 
#include &lt;Core/GuiInterface/GuiVar.h>    // GUI data interface

class Sort : public Module
{
protected:

  // each module usually has unique ports, gui elements and
  // member functions.

  // Sort specific port and gui data members
  WordListIPort *iport_;
  WordListOPort *oport_;
  GuiInt algo_;

  // Sort specific member functions
  string* get_data();
  int get_control();
  void send_data();

public:

  // all modules need to declare and implement these

  // constructor (with appropriate initializers)
  Sort(const string&amp; id) :
    Module("Sort", id, Source, "WordList", "SCIRun"),
    algo_("alg_to_use", id, this),
    iport_(0),
    oport_(0),
    algo_(0) { /* do nothing */ }

  // virtual destructor
  virtual ~Sort() { /* do nothing */ };

  // virtual execute function
  virtual void execute();
        
};
      </computeroutput>

      <para>
        We've already implemented the execute function, but it depends on
        get_data(), get_control() and send_data().  Let's write those now.
        Assuming that our module actually has the ports we need (how
        to give ports to a module will be discussed later on), we 
        need to be able to get the data from the input port:
      </para>

      <computeroutput>

string *Sort::get_data()
{
  // data is passed between modules as handles
  WordListHandle wlh;

  // first get a pointer to the input port named "InList"
  iport_ = (WordListIPort*)get_iport("InList");

  // verify that the port was found
  if (!iport_) return 0;

  // verify that the port is connected and has data (blocking call!)
  // if so, the handle will be associated with the data
  if (!iport_->get(wlh)) return 0;

  // return the data pointer associated with the handle (may be NULL!)
  return wlh.get_rep();
}
      </computeroutput>

      <para>
        Now we have the data, but we can't call the sort function until
        we know which sort algorithm to use, so we have to query the state 
        of the GUI:
      </para>

      <computeroutput>

int Sort::get_control()
{
  // prep the GUI element associated with algo_
  algo_.reset();

  // return the state of algo_'s GUI element
  return algo_.get();
}
      </computeroutput>

      <para>
        Now we have enough information (the data and control) to call the
        sort function.  After that we'll want to relay the results to the
        next module (or modules) in the network, i.e. we have to send the
        results of the sort function to the output port:
      </para>

      <computeroutput>

void Sort::send_data(string *list)
{
  // get a pointer to the output port named "OutList"
  oport_ = (WorldListOPort*)get_oport("OutList");

  // send the data to the port.  the pointer is automatically
  // wrapped into a WordListHandle by the send
  oport_->send(list);
}
      </computeroutput>

      <para>
        We have now implmented a new module.  But it isn't quite
        complete.  We made a couple assumptions while writing the
        class: the module has one input port and one output port and the
        module has a GUI with one element capable of representing an
        integer.  This leads us to the next point.  A module is not 
        just a C++ file which defines a new module class.  A module
        needs at least one, and possibly two, more files: an
        XML file and a TCL file.
      </para>
    
      <para>
        The XML file is used to describe how many and what type of
        ports a module has, which category it belongs to and much
        more.  The TCL file describes the GUI of a module, if it has
        one.  Let's create these files for the Sort module.  Also by
        convention, these files have the base name of the module.
      </para>

      <para>
        First, the XML file Sort.xml:
      </para>

      <computeroutput>

&lt;component name="Sort" category="WordList">
  &lt;overview>
    &lt;authors>
      &lt;author>
        Eddie Murphy
      &lt;/author>
    &lt;/authors>
    &lt;summary>
      &lt;p>
        This module sorts a word list
      &lt;/p>
    &lt;/summary>
  &lt;/overview>
  &lt;io>
    &lt;inputs lastportdynamic="no">
      &lt;port>
        &lt;name>InList&lt;/name>
        &lt;datatype>SCIRun::WordList&lt;/datatype>
      &lt;/port>
    &lt;/inputs>
    &lt;outputs>
      &lt;port>
        &lt;name>OutList&lt;/name>
        &lt;datatype>SCIRun::WordList&lt;/datatype>
      &lt;/port>
    &lt;/outputs>
  &lt;/io>
&lt;component>
      </computeroutput> 

      <para>
        And the TCL file Sort.tcl:
      </para>

      <computeroutput>

itcl_class SCIRun_WordList_Sort {
  inherit Module
  
  constructor { config } {
    set name Sort
    
    set_defaults
  }

  method set_defaults {} {
    global $this-alg_to_use
    set $this-alg_to_use 1
  }

  method ui {} {
    set w .ui[modname]
    if { [winfo exists $w] } {
      raise $w
      return
    }

    toplevel $w

    label $w.title -text "Sort Algorithms"
    label $w.option1 -text "1. Quick Sort"
    label $w.option2 -text "2. Bubble Sort"
    label $w.option3 -text "3. Insertion Sort"

    entry $w.choice -textvar $this-alg_to_use

    pack $w.title $w.option1 $w.option2 $w.option3 $w.choice -side top
  }
}
      </computeroutput>

      <para>
        Now that we have all the files needed for a new module, we
        need a place to put them.  All SCIRun modules are
        members of groups - categories and packages - which are
        directory structures for organizing modules.  These directory
        structures are converted to .so libraries at build time by
        compiling and linking the files within them.  Packages,
        categories and the modules inside them are only usable by
        SCIRun in their .so form, so let's put the Sort module into a
        category and a package, and convert it to a .so library file. 
      </para>

      <para>
        All SCIRun packages have the same basic directory structure:
      </para>

      <computeroutput>

PACKAGE_NAME ---+- Core ------+- Datatypes
                |             +- Algorithms
                |
                +- Dataflow --+- Ports
                              +- Modules
                              +- GUI
                              +- XML
      </computeroutput>

      <para>
        In fact, that directory structure is required in order for
        a package to be considered valid.  It is possible for a
        package to have more directories, but generally not fewer.        
        Even the main SCIRun source tree, which is a package in
        itself, exhibits this structure.  Each package has two sides
        in it's source tree.  Core defines datatypes and algorithms,
        which are not necessarily associated with dataflow programming.
        Dataflow defines ports and modules, which are based on datatypes
        and algorithms found in the Core side.
      </para>

      <para>
        Packages contain one or more categories, which reside
        inside the Dataflow/Modules directory.  Each category contains
        one or more modules: 
      </para>
          
      <computeroutput>

Modules ---+- Category1 ---+- Module1.cc
           |               +- Module2.cc
           |               +- ...
           |               +- ModuleX.cc
           |
           +- Category2 ---+- Module1.cc
           |               +- Module2.cc
           |               +- ...
           |               +- ModuleY.cc
           +- ...
           |
           +- CategoryZ
      </computeroutput>

      <para>
        Suppose we would like to put Sort inside the WordList category
        of the SCIRun package.  If the package and category already
        exist, then we just need to copy the files we made into the
        appropriate directories:
      </para>

      <computeroutput>

cp Sort.cc SCIRun/src/Dataflow/Modules/WordList
cp Sort.xml SCIRun/src/Dataflow/XML
cp Sort.tcl SCIRun/src/Dataflow/GUI
      </computeroutput>

      <para>
        If, on the other hand, we wanted to put it into a package
        other than SCIRun, we would do the following:
      </para>

      <computeroutput>

cp Sort.cc PACKAGE_NAME/Dataflow/Modules/WordList
cp Sort.xml PACKAGE_NAME/Dataflow/XML
cp Sort.tcl PACKAGE_NAME/Dataflow/GUI
      </computeroutput>

      <para>
        If the package and/or category does not already exist, then
        we would first have to build the appropriate directory structure
        to put the files into.
      </para>

      <para>
        Recall that any given package is only useful to SCIRun in it's
        .so form.  In order to use Sort, we'll have to make sure that
        it gets included into the building of the SCIRun package.
        Fortunately, SCIRun comes with a makefile system
        that knows how to build all the .so's for itself and all
        external packages.  The makefile system is composed of
        makefile fragments found in EVERY directory within the SCIRun
        source tree and it's packages.  The fragments all live in
        files named "sub.mk".  The contents of a sub.mk file depend on
        which directory it lives in.  The following are sub.mk files
        for the SCIRun Modules directory (SCIRun/src/Dataflow/Modules)
        and the WordList Category directory
        (SCIRun/src/Dataflow/Modules/WordList), respectively:
      </para>

      <computeroutput>

SRCDIR := Dataflow/Modules
 
SUBDIRS := \
        $(SRCDIR)/DataIO\
        $(SRCDIR)/Fields\
        $(SRCDIR)/Math\
        $(SRCDIR)/Render\
        $(SRCDIR)/Visualization\
#[INSERT NEW CATEGORY DIR HERE]
 
include $(SCIRUN_SCRIPTS)/recurse.mk
      </computeroutput>

      <computeroutput>

include $(SCIRUN_SCRIPTS)/smallso_prologue.mk
 
SRCDIR   := Dataflow/Modules/WordList
 
SRCS     += \
#[INSERT NEW CODE FILE HERE]
 
PSELIBS := Dataflow/Network Dataflow/Ports \
        Core/Datatypes Core/GuiInterface \
        Core/Persistent Core/Util \
        Core/TkExtensions
 
LIBS := -lm
 
include $(SCIRUN_SCRIPTS)/smallso_epilogue.mk
      </computeroutput>

      <para>
        All we have to do is add the category directory to the first
        sub.mk file, just before the #[INSERT ... HERE] comment:
      </para>

      <computeroutput>
 
SRCDIR := Dataflow/Modules
 
SUBDIRS := \
        $(SRCDIR)/DataIO\
        $(SRCDIR)/Fields\
        $(SRCDIR)/Math\
        $(SRCDIR)/Render\
        $(SRCDIR)/Visualization\
        $(SRCDIR)/WordList\
#[INSERT NEW CATEGORY DIR HERE]
 
include $(SCIRUN_SCRIPTS)/recurse.mk
      </computeroutput>

      <para>
        and then add the .cc file to the second sub.mk file, again
        just before the #[INSERT ... HERE] comment:
      </para>

      <computeroutput>
 
include $(SCIRUN_SCRIPTS)/smallso_prologue.mk
 
SRCDIR   := Dataflow/Modules/WordList
 
SRCS     += \
         $(SRCDIR)/Sort.cc\
#[INSERT NEW CODE FILE HERE]
 
PSELIBS := Dataflow/Network Dataflow/Ports \
        Core/Datatypes Core/GuiInterface \
        Core/Persistent Core/Util \
        Core/TkExtensions
 
LIBS := -lm
 
include $(SCIRUN_SCRIPTS)/smallso_epilogue.mk
      </computeroutput>

      <para>
        Now we can build the newly created Sort module by
        issuing a make command in the build directory.  After
        that we can run SCIRun and use the new module:
      </para>

      <computeroutput>

cd <term>BUILD_DIR</term>
gmake
      </computeroutput>

      <para>
        Some important aspects of developing a new module that we've
        glossed over are all the conventions used.  We already know
        that each of the module files (.cc, .xml and .tcl) must all
        have the same base name (i.e. the name of the module), but there
        are others as well.  Make sure that the name of the package,
        category and module are spelled exactly the same, including
        case, in each of the files, .cc, .xml, and .tcl, respectively:
      </para>

      <computeroutput>

...
Module("Sort", id, Source, "WordList", "SCIRun"),
...
      </computeroutput>

      <computeroutput>

...
&lt;component name="Sort" category="WordList">
...
      </computeroutput>

      <computeroutput>

...
itcl_class SCIRun_WordList_Sort { 
...
      </computeroutput>

      <para>
        After editing sub.mk files, make sure that each of the entries
        in the SUBDIRS or SRCS are followed by a backslash-endline pair,
        and that the #[INSERT ... HERE] line isn't changed (other than 
        moved down a line) or been removed:
      </para>

      <computeroutput>

SUBDIRS := \
        $(SRCDIR)/DataIO\
        $(SRCDIR)/Fields\
        $(SRCDIR)/Math\
        $(SRCDIR)/Render\
        $(SRCDIR)/Visualization\
        $(SRCDIR)/WordList\
#[INSERT NEW CATEGORY DIR HERE]
      </computeroutput>

      <computeroutput>

SRCS     += \
         $(SRCDIR)/Sort.cc\
#[INSERT NEW CODE FILE HERE]
      </computeroutput>
    </sect2>

    <sect2>
      <title>Creating new modules semi-automatically</title>

      <para>
        Until you become a seasoned SCIRun developer, all the work
        discussed above will seem too daunting to get started with
        development.  For this reason SCIRun comes with the Component
        Wizard - a tool for automatically generating all the files
        needed to start a new module from scratch.  It even edits
        the makefile system to add the new module.
      </para>
   
      <para>
        The Component Wizard has a visual interface in which you
        graphically construct the module you wish to create.  Once you
        are finished, the Component Wizard uses the information
        gathered to automatically create skeletons of all the needed
        files, which are fully ready to be built.  All that's left to
        do is fill in the execute function and design a GUI.
      </para>

      <para>
        Access the Component Wizard from the main SCIRun menu,
        File->New->Module:
      </para>

      <figure file="../images/research_menuheader.jpg" caption="The Component Wizard"/>

      <figure file="../images/research_header_sm.gif" caption="The blah"/>
      <para>
        The Component Wizard
      </para>

    </sect2>

    <sect2>
      <title>Port</title>
      
      <para>
        Ports are the analog of formal paramaters of a C function.
        They are used to connect modules together and they enforce type
        matching.
      </para>
    </sect2>

    <sect2>
      <title>Connection</title>
      <para>
      </para>
    </sect2>
    
    <sect2>
      <title>Network</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Network Editor</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Examples</title>
   
    
      <para>
        To get data into and out of your module's execute function, you
        need to use the module's ports.  In order to use the ports, 
        you first need to get a pointer to a specific port.  Then, call
        that port's get() function with a handle to the type of data
        expected on the port.  On success, the handle passed to get()
        will represent the data that is on that input port:
      </para>
    
      <computeroutput>

        #include &lt;Dataflow/Ports/MatrixPort.h&gt;

        ...

        void SomeModule::execute() {

          //The input port for this module is of type Matrix, and is
          // named "Input Matrix"

          MatrixIPort *iport = get_iport("Input Matrix");

          MatrixHandle InputMatrix;

          int connected = iport->get(InputMatrix);

          if (!connected) {
            printf("There is no connection for 'Input Matrix'!");
	    return;
          }
        
	  ...
        }
      </computeroutput>
    </sect2>
  </sect1>
</chapter>













