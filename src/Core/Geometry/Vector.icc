#include <SCICore/Exceptions/Exceptions.h>

using SCICore::ExceptionsSpace::Exception;
using SCICore::ExceptionsSpace::AssertionFailed;

inline Vector::Vector()
{
#if SCI_ASSERTION_LEVEL >= 4
    uninit=1;
#endif
}

inline Vector::Vector(const Vector& p)
{
    _x=p._x;
    _y=p._y;
    _z=p._z;
#if SCI_ASSERTION_LEVEL >= 4
    uninit=0;
#endif
}

inline double Vector::length2() const
{
    ASSERTL4(!uninit);
    return _x*_x+_y*_y+_z*_z;
}

inline Vector& Vector::operator=(const Vector& v)
{
    ASSERTL4(!v.uninit);
    _x=v._x;
    _y=v._y;
    _z=v._z;
#if SCI_ASSERTION_LEVEL >= 4
    uninit=0;
#endif
    return *this;
}

inline Vector Vector::operator*(const double s) const
{
    ASSERTL4(!uninit);
    return Vector(_x*s, _y*s, _z*s);
}

inline Vector Vector::operator/(const double d) const
{
    ASSERTL4(!uninit);
    return Vector(_x/d, _y/d, _z/d);
}

inline Vector Vector::operator/(const Vector& v2) const
{
    ASSERTL4(!uninit && !v2.uninit);
    return Vector(_x/v2._x, _y/v2._y, _z/v2._z);
}

inline Vector Vector::operator+(const Vector& v2) const
{
    ASSERTL4(!uninit && !v2.uninit);
    return Vector(_x+v2._x, _y+v2._y, _z+v2._z);
}

inline Vector Vector::operator-(const Vector& v2) const
{
    ASSERTL4(!uninit && !v2.uninit);
    return Vector(_x-v2._x, _y-v2._y, _z-v2._z);
}

inline Vector& Vector::operator+=(const Vector& v2)
{
    ASSERTL4(!uninit && !v2.uninit);
    _x+=v2._x;
    _y+=v2._y;
    _z+=v2._z;
    return *this;
}

inline Vector& Vector::operator-=(const Vector& v2)
{
    ASSERTL4(!uninit && !v2.uninit);
    _x-=v2._x;
    _y-=v2._y;
    _z-=v2._z;
    return *this;
}

inline Vector Vector::operator-() const
{
    ASSERTL4(!uninit);
    return Vector(-_x,-_y,-_z);
}

inline double Vector::length() const
{
    ASSERTL4(!uninit);
    return Sqrt(_x*_x+_y*_y+_z*_z);
}

inline Vector Abs(const Vector& v)
{
    using SCICore::Math::Abs;

    ASSERTL4(!v.uninit);
    double x=Abs(v._x);
    double y=Abs(v._y);
    double z=Abs(v._z);
    return Vector(x,y,z);
}

inline Vector Cross(const Vector& v1, const Vector& v2)
{
    ASSERTL4(!v1.uninit && !v2.uninit);
    return Vector(
	v1._y*v2._z-v1._z*v2._y,
	v1._z*v2._x-v1._x*v2._z,
	v1._x*v2._y-v1._y*v2._x);
}

inline Vector Interpolate(const Vector& v1, const Vector& v2,
			  double weight)
{
    ASSERTL4(!v1.uninit && !v2.uninit);
    double weight1=1.0-weight;
    return Vector(
	v2._x*weight+v1._x*weight1,
	v2._y*weight+v1._y*weight1,
	v2._z*weight+v1._z*weight1);
}

inline Vector& Vector::operator*=(const double d)
{
    ASSERTL4(!uninit);
    _x*=d;
    _y*=d;
    _z*=d;
    return *this;
}

inline void Vector::x(double d)
{
#if SCI_ASSERTION_LEVEL >= 4
    uninit=0;
#endif
    _x=d;
}

inline double Vector::x() const
{
    ASSERTL4(!uninit);
    return _x;
}

inline void Vector::y(double d)
{
#if SCI_ASSERTION_LEVEL >= 4
    uninit=0;
#endif
    _y=d;
}

inline double Vector::y() const
{
    ASSERTL4(!uninit);
    return _y;
}

inline void Vector::z(double d)
{
#if SCI_ASSERTION_LEVEL >= 4
    uninit=0;
#endif
    _z=d;
}

inline double Vector::z() const
{
    ASSERTL4(!uninit);
    return _z;
}



inline void Vector::u(double d)
{
#if SCI_ASSERTION_LEVEL >= 4
    uninit=0;
#endif
    _x=d;
}

inline double Vector::u() const
{
    ASSERTL4(!uninit);
    return _x;
}

inline void Vector::v(double d)
{
#if SCI_ASSERTION_LEVEL >= 4
    uninit=0;
#endif
    _y=d;
}

inline double Vector::v() const
{
    ASSERTL4(!uninit);
    return _y;
}

inline void Vector::w(double d)
{
#if SCI_ASSERTION_LEVEL >= 4
    uninit=0;
#endif
    _z=d;
}

inline double Vector::w() const
{
    ASSERTL4(!uninit);
    return _z;
}




inline void Vector::rotz90(const int c)
{
    // Rotate by c*90 degrees counter clockwise
    switch(c%4){
    case 0:
	// 0 degrees, do nothing
	break;
    case 1:
	// 90 degrees
	{
	    double newx=-_y;
	    _y=_x;
	    _x=newx;
	}
	break;
    case 2:
	// 180 degrees
	_x=-_x;
	_y=-_y;
	break;
    case 3:
	// 270 degrees
	{
	    double newy=-_x;
	    _x=_y;
	    _y=newy;
	}
	break;
    }
}


inline Point Vector::point() const
{
    ASSERTL4(!uninit);
    return Point(_x,_y,_z);
}

inline double Dot(const Vector& v1, const Vector& v2)
{
    ASSERTL4(!v1.uninit && !v2.uninit);
    return v1._x*v2._x+v1._y*v2._y+v1._z*v2._z;
}

inline double Dot(const Vector& v, const Point& p)
{
    ASSERTL4(!v.uninit && !p.uninit);
    return v._x*p._x+v._y*p._y+v._z*p._z;
}

inline
double Vector::normalize()
{
    ASSERTL4(!uninit);
    double l2=_x*_x+_y*_y+_z*_z;
    double l=Sqrt(l2);
    ASSERT(l>0.0);
    _x/=l;
    _y/=l;
    _z/=l;
    return l;
}

