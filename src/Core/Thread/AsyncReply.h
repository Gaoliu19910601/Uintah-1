/*
 * This file was automatically generated by SCC - do NOT edit!
 * You should edit AsyncReply.scc instead 
 */

#ifndef SCI_THREAD_ASYNCREPLY_H
#define SCI_THREAD_ASYNCREPLY_H 1

/*
 * Creates a single slot for some return value.  The <i>wait</i> method
 * waits for a value to be sent from another thread via the <i>reply</i>
 * method.  This is typically used to provide a simple means of returning
 * data from a server thread.  An <b>AsyncReply</b> object is created on the
 * stack, and some request is sent (usually via a <b>Mailbox</b>) to a server
 * thread.  Then the thread will block in <i>wait</i> until the server thread
 * receives the message and responds using <i>reply</i>.
 *
 * <p><b>AsyncReply</b> is a one-shot wait/reply pair - a new <b>AsyncReply</b>
 * object must be created for each reply.  Only a single thread should
 * call <i>wait</i> and a single thread shuold call <i>reply</i>.
 */

#include "Thread.h"
#include "Semaphore.h"


/**************************************
 
CLASS
   AsyncReply
   
KEYWORDS
   AsyncReply
   
DESCRIPTION
   Creates a single slot for some return value.  The <i>wait</i> method
   waits for a value to be sent from another thread via the <i>reply</i>
   method.  This is typically used to provide a simple means of returning
   data from a server thread.  An <b>AsyncReply</b> object is created on the
   stack, and some request is sent (usually via a <b>Mailbox</b>) to a server
   thread.  Then the thread will block in <i>wait</i> until the server thread
   receives the message and responds using <i>reply</i>.
  
   <p><b>AsyncReply</b> is a one-shot wait/reply pair - a new <b>AsyncReply</b>
   object must be created for each reply.  Only a single thread should
   call <i>wait</i> and a single thread shuold call <i>reply</i>.
PATTERNS


WARNING
   
****************************************/

template<class Item> class AsyncReply {
    const char* name;
    Item value;
    Semaphore sema;
public:
    //////////
    //Create the AsyncReply object.  <i>name</i> should be a static string which describes the
    //primitive for debugging purposes.
    AsyncReply(const char* name);

    //////////
    //Destroy the object
    ~AsyncReply() ;

    //////////
    //Wait until the reply is sent by anothe thread, then return that reply.
    Item wait() ;

    //////////
    //Send the reply to the waiting thread.
    void reply(Item reply) ;
};

template<class Item> AsyncReply< Item>::AsyncReply(const char* name): name(name), sema("AsyncReply semaphore", 0) {}

template<class Item> AsyncReply< Item>::~AsyncReply() {}

template<class Item> Item AsyncReply< Item>::wait() {
    int s=Thread::couldBlock(name);
    sema.down();
    Thread::couldBlock(s);
    return value;
}

template<class Item> void AsyncReply< Item>::reply(Item reply) {
    value=reply;
    sema.up();
}

#endif
