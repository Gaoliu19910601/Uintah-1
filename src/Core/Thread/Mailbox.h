/*
 * This file was automatically generated by SCC - do NOT edit!
 * You should edit Mailbox.scc instead 
 */

#ifndef SCI_THREAD_MAILBOX_H
#define SCI_THREAD_MAILBOX_H 1

/*
 * A thread-safe, fixed-length FIFO queue which allows multiple
 * concurrent senders and receivers.  Multiple threads send <b>Item</b>s
 * to the mailbox, and multiple thread may receive <b>Item</b>s from the
 * mailbox.  Items are typically pointers to a message structure.
 */

#include "Thread.h"
#include "Semaphore.h"
#include "Mutex.h"
#include "ConditionVariable.h"



/**************************************
 
CLASS
   Mailbox
   
KEYWORDS
   Mailbox
   
DESCRIPTION
   A thread-safe, fixed-length FIFO queue which allows multiple
   concurrent senders and receivers.  Multiple threads send <b>Item</b>s
   to the mailbox, and multiple thread may receive <b>Item</b>s from the
   mailbox.  Items are typically pointers to a message structure.
PATTERNS


WARNING
   
****************************************/

template<class Item> class Mailbox {
    Mutex mutex;
    Item* ring_buffer;
    int head;
    int len;
    int max;
    ConditionVariable empty;
    ConditionVariable full;
    Semaphore rendezvous;
    int send_wait;
    int recv_wait;
    const char* name;
    inline int ringnext(int inc) ;
public:
    //////////
    //Create a mailbox with a maximum queue size of <i>size</i> items.  If size is zero, then
    //the mailbox will use <i>rendevous symantics</i>, where a sender will block until a reciever
    //is waiting for the item.  The item will be handed off synchronously. <i>name</i> should be
    //a static string which describes the primitive for debugging purposes.
    Mailbox(const char* name, int size) ;
    
    //////////
    //Destroy the mailbox.  All items in the queue are silently dropped.
    ~Mailbox() ;
    
    //////////
    //Puts <i>msg</i> in the queue.  If the queue is full, the thread will be blocked until
    //there is room in the queue.  Multiple threads may call <i>send</i> concurrently, and the
    //messages will be placed in the queue in an undefined order.
    void send(Item msg) ;
    
    //////////
    //Attempt to send <i>msg</i> to the queue.  If the queue is full, the thread will not be
    //blocked, and <i>try_send</i> will return false.  Otherwise, <i>try_send</i> will return 
    //false.  This may never complete if the reciever only uses <i>try_recieve</i>.  
    bool try_send(Item msg);
    
    //////////
    //Recieve an item from the queue.  If the queue is empty, the thread will block until another
    //thread sends an item.  Multiple threads may call <i>recieve</i> concurrently, but no guarantee
    //is made as to which thread will recieve the next token.  However, implementors should give
    //preference to the thread that has been waiting the longest.
    Item receive() ;

    //////////
    //Attempt to recieve <i>item</i> from the mailbox.  If the queue is empty, the thread is
    //blocked and <i>try_recieve</i> will return false.  Otherwise, <i>try_recieve</i> returns true.
    bool try_receive(Item& item) ;
    
    //////////
    //Return the maximum size of the mailbox queue, as given in the constructor.
    int size() const ;

    //////////
    //Return the number of items currently in the queue
    int nitems() const ;
};

template<class Item> inline int Mailbox< Item>::ringnext(int inc) {
    return max==0?0:((head+inc)%max);
}

template<class Item> Mailbox< Item>::Mailbox(const char* name, int size)
	: name(name), mutex("Mailbox lock"),
      empty("Mailbox empty condition"), full("Mailbox full condition"),
      rendezvous("Mailbox rendezvous semaphore", 0)
{
    ring_buffer=new Item[size==0?1:size];
    head=0;
    len=0;
    send_wait=0;
    recv_wait=0;
    max=size;
}

template<class Item> Mailbox< Item>::~Mailbox() {
    delete[] ring_buffer;
}

template<class Item> void Mailbox< Item>::send(Item msg) {
    int s=Thread::couldBlock(name);
    mutex.lock();
    // See if the message buffer is full...
    int rmax=max==0?1:max;
    while(len == rmax){
        send_wait++;
        full.wait(mutex);
        send_wait--;
    }
    ring_buffer[ringnext(len)]=msg;
    len++;
    if(recv_wait)
        empty.cond_signal();
    mutex.unlock();
    if(max==0)
        rendezvous.down();
    Thread::couldBlock(s);
}

template<class Item> bool Mailbox< Item>::try_send(Item msg){
    mutex.lock();
    // See if the message buffer is full...
    int rmax=max==0?1:max;
    if(len == rmax){
        mutex.unlock();
        return false;
    }
    if(max == 0 && recv_wait==0){
        // No receivers waiting, so rendezvous will fail. Return now.
        mutex.unlock();
        return false;
    }

    ring_buffer[ringnext(len)]=msg;
    len++;
    if(recv_wait)
        empty.cond_signal();
    mutex.unlock();
    if(max==0)
        rendezvous.down();  // Won't block for long, since a receiver
                            // will wake us up
    return true;
}

template<class Item> Item Mailbox< Item>::receive() {
    int s=Thread::couldBlock(name);
    mutex.lock();
    while(len == 0){
        recv_wait++;
        empty.wait(mutex);
        recv_wait--;
    }
    Item val=ring_buffer[head];
    head=ringnext(1);
    len--;
    if(send_wait)
        full.cond_signal();
    mutex.unlock();
    if(max==0)
        rendezvous.up();
    Thread::couldBlock(s);
    return val;
}

template<class Item> bool Mailbox< Item>::try_receive(Item& item) {
    mutex.lock();
    if(len == 0){
        mutex.unlock();
        return false;
    }
    item=ring_buffer[head];
    head=ringnext(1);
    len--;
    if(send_wait)
        full.cond_signal();
    mutex.unlock();
    if(max==0)
        rendezvous.up();
    return true;
}

template<class Item> int Mailbox< Item>::size() const {
    return max;
}

template<class Item> int Mailbox< Item>::nitems() const {
    return len;
}

#endif
