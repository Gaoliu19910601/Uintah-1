/*

 The MIT License

 Copyright (c) 1997-2012 Center for the Simulation of Accidental Fires and
 Explosions (CSAFE), and  Scientific Computing and Imaging Institute (SCI),
 University of Utah.

 License for the specific language governing rights and limitations under
 Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation
 the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included
 in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.

 */

//-----------------------------------------------------------------------------

/*
Copyright (c) 2009, 2010 Mutsuo Saito, Makoto Matsumoto and Hiroshima
University.  All rights reserved.
Copyright (c) 2011 Mutsuo Saito, Makoto Matsumoto, Hiroshima
University and University of Tokyo.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of the Hiroshima University nor the names of
      its contributors may be used to endorse or promote products
      derived from this software without specific prior written
      permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifndef MERSENNE_TWISTER_GPU_H
#define MERSENNE_TWISTER_GPU_H

#include <sci_defs/cuda_defs.h>

#define MTGPDC_N 176
#define MTGPDC_FLOOR_2P 128
#define MEXP 11213
#define N MTGPDC_N
#define THREAD_NUM MTGPDC_FLOOR_2P
#define LARGE_SIZE (THREAD_NUM * 3)
#define PARAM_NUM_MAX mtgpdc_params_11213_num
#define BLOCK_NUM_MAX 200
#define TBL_SIZE 16
#define MTGP64DC_PARAM_TABLE mtgp64dc_params_fast_11213

//struct mtgp64_kernel_status_t;

/**
 * kernel I/O
 * This structure must be initialized before first use.
 */
struct mtgp64_kernel_status_t {
  uint64_t status[N];
};

/*
 * Texture References.
 */
texture<uint32_t, 1, cudaReadModeElementType> tex_param_ref;
texture<uint32_t, 1, cudaReadModeElementType> tex_temper_ref;
texture<uint32_t, 1, cudaReadModeElementType> tex_double_ref;


/*
 * Generator Parameters.
 */
__constant__ uint32_t pos_tbl[BLOCK_NUM_MAX];
__constant__ uint32_t sh1_tbl[BLOCK_NUM_MAX];
__constant__ uint32_t sh2_tbl[BLOCK_NUM_MAX];
__constant__ uint32_t mask[2];


/**
 * Shared memory
 * The generator's internal status vector.
 */
__shared__ uint32_t status[2][LARGE_SIZE]; /* 512 * 3 elements, 12288 bytes. */

#ifdef __cplusplus
extern "C" {
#endif
/**
 * MTGP64_PARAMS_FAST_T
 *
 * MTGP64 parameters.
 * Some elements are redundant to keep structure simple.
 *
 * pos is a pick up position which is selected to have good
 * performance on GPUs.  3 < pos < Q, where Q is a
 * maximum number such that the size of status array - Q is a power of
 * 2.  For example, when mexp is 44497, size of 64-bit status array
 * is 696, and Q is 184, then pos is between 4 and 183. This means
 * 512 parallel calculations is allowed when mexp is 44497.
 *
 * poly_sha1 is SHA1 digest of the characteristic polynomial of
 * state transition function. SHA1 is calculated based on printing
 * form of the polynomial. This is important when we use parameters
 * generated by the dynamic creator which
 *
 * mask This is a mask to make the dimension of state space have
 * just Mersenne Prime. This is redundant.
 */
typedef struct MTGP64_PARAMS_FAST_T {
  int mexp; /**< Mersenne exponent. This is redundant. */
  int pos; /**< pick up position. */
  int sh1; /**< shift value 1. 0 < sh1 < 32. */
  int sh2; /**< shift value 2. 0 < sh2 < 32. */
  uint64_t tbl[16]; /**< a small matrix. */
  uint64_t tmp_tbl[16]; /**< a small matrix for tempering. */
  uint64_t dbl_tmp_tbl[16]; /**< a small matrix for tempering and
   converting to double. */
  uint64_t mask; /**< This is a mask for state space */
  unsigned char poly_sha1[21]; /**< SHA1 digest */
} mtgp64_params_fast_t;

__global__ void mtgp64_uint64_kernel(mtgp64_kernel_status_t* d_status,
                                     uint64_t* d_data,
                                     int size);

__global__ void mtgp64_double01_kernel(mtgp64_kernel_status_t* d_status,
                                       double* d_data,
                                       int size);

__device__ uint64_t temper(uint32_t VH,
                           uint32_t VL,
                           uint32_t TL,
                           int bid);

__device__ double temper_double01(uint32_t VH,
                                  uint32_t VL,
                                  uint32_t TL,
                                  int bid);

__device__ void para_rec(uint32_t *RH,
                         uint32_t *RL,
                         uint32_t X1H,
                         uint32_t X1L,
                         uint32_t X2H,
                         uint32_t X2L,
                         uint32_t YH,
                         uint32_t YL,
                         int bid);

__device__ void status_read(uint32_t status[2][LARGE_SIZE],
                            const mtgp64_kernel_status_t *d_status,
                            int bid,
                            int tid);

__device__ void status_write(mtgp64_kernel_status_t *d_status,
                             const uint32_t status[2][LARGE_SIZE],
                             int bid,
                             int tid);

#ifdef __cplusplus
}
#endif

namespace Uintah {

  class MTRandGPU {

  public:
    MTRandGPU();

    ~MTRandGPU();

    void initMTRandGPU();


  private:
    void make_constant(const mtgp64_params_fast_t params[], int block_num);

    void make_texture(const mtgp64_params_fast_t params[],
                      uint32_t *d_texture_tbl[3],
                      int block_num);

    void make_kernel_data64(mtgp64_kernel_status_t *d_status,
                            mtgp64_params_fast_t params[],
                            int block_num);


    void make_uint64_random(mtgp64_kernel_status_t* d_status,
                            int num_data,
                            int block_num);

    void make_double01_random(mtgp64_kernel_status_t* d_status, int num_data, int block_num);


    void mtgp64_init_state(uint64_t array[],
                           const mtgp64_params_fast_t *para,
                           uint64_t seed);

  }; // class MTRandGPU

} // namespace Uintah


#endif
