/*
 *  String.icc: inline functions for String utility class
 *
 *  Written by:
 *   Steven G. Parker
 *   Department of Computer Science
 *   University of Utah
 *   Feb. 1994
 *
 *  Copyright (C) 1994 SCI Group
 */

#include <SCICore/Util/Assert.h>
#include <string.h>
#include <ctype.h>

inline clString::clString()
{
    p=0;
}

inline clString::clString(const clString& str)
{
    if(str.p)str.p->n++;
    p=str.p;
}

inline clString::clString(int, char* s)
{
    p=new srep;
    p->s=s;
}

inline clString::~clString()
{
    if(p && --p->n == 0){
	if(p->s)delete[] p->s;
	delete p;
    }
}

inline clString& clString::operator=(const char* s)
{
    if(!p || p->n > 1){
	// Disconnect self
	if(p)p->n--;
	p=new srep;
    } else {
	// Free old clString
	if(p->s)delete [] p->s;
    }
    int len=strlen(s);
    p->s=new char[len+1];
    strcpy(p->s,s);
    return *this;
}

inline clString& clString::operator=(const clString& str)
{
    if(str.p)str.p->n++;		// Protect against st=st
    if(p && --p->n==0){
	if(p->s)delete[] p->s;
	delete p;
    }
    p=str.p;
    return *this;
}

inline int clString::operator==(const char* s) const
{
    return strcmp((p && p->s)?p->s:"", s) == 0;
}

inline int clString::operator==(const clString& str) const
{
    return p==str.p || strcmp((p && p->s)?p->s:"", (str.p && str.p->s)?str.p->s:"") == 0;
}

inline int clString::operator!=(const char* s) const
{
    return strcmp((p && p->s)?p->s:"", s) != 0;
}

inline int clString::operator!=(const clString& str) const
{
    return p != str.p && strcmp((p && p->s)?p->s:"", (str.p && str.p->s)?str.p->s:"") != 0;
}

inline int clString::operator<(const char* s) const
{
    return strcmp((p && p->s)?p->s:"", s) < 0;
}

inline int clString::operator<(const clString& str) const
{
    return p != str.p && strcmp((p && p->s)?p->s:"", (str.p && str.p->s)?str.p->s:"") < 0;
}

inline int clString::operator>(const char* s) const
{
    return strcmp((p && p->s)?p->s:"", s) > 0;
}

inline int clString::operator>(const clString& str) const
{
    return p != str.p && strcmp((p && p->s)?p->s:"", (str.p && str.p->s)?str.p->s:"") > 0;
}

inline const char* clString::operator()() const
{
    return (p && p->s)?p->s:"";
}

inline char clString::operator()(int index) const
{
    ASSERT(p != 0 && p->s != 0);
    ASSERTRANGE(index, 0, (int)strlen(p->s));
    return p->s[index];
}

inline int clString::len() const
{
    return p?strlen(p->s):0;
}

inline int clString::is_alpha(int i)
{
    ASSERT(p != 0 && p->s);
    ASSERTRANGE(i, 0, (int)strlen(p->s));
    return isalpha(p->s[i]);
}

inline int clString::is_digit(int i)
{
    ASSERT(p != 0);
    ASSERTRANGE(i, 0, (int)strlen(p->s));
    return isdigit(p->s[i]);
}
