/*
 * This file was automatically generated by SCC - do NOT edit!
 * You should edit Thread.scc instead 
 */

#ifndef SCI_THREAD_THREAD_H
#define SCI_THREAD_THREAD_H 1


class ThreadGroup;
class ThreadError;
struct ThreadEvent;
class ThreadTopology;
class ThreadListener;

#include "ParallelBase.h"
#include "Runnable.h"

#include <stdio.h>


typedef long long SysClock;


struct Thread_private;


/**************************************
 
CLASS
   Thread
   
KEYWORDS
   Thread
   
DESCRIPTION
 
PATTERNS


WARNING
   
****************************************/

class SCICORESHARE Thread {
    friend class Mutex;
    friend class Semaphore;
    friend class Barrier;
    friend class PoolMutex;
    friend class WorkQueue;
    
    //////////
    //<i>No documentation provided</i>
    Thread(const Thread&);

    //////////
    //<i>No documentation provided</i>
    ~Thread() ;
    bool daemon;
    bool detached;
    Runnable* runner;
    char* threadname;
    Thread_private* priv;
    ThreadGroup* group;
    int cpu;
    int priority;
    ThreadError* abort_handler;
    
    //////////
    //This method is specific to a particular thread implementation.
    void os_start(bool stopped);

    //////////
    //This is for an internal initialization.  Do not call it directly.
    static void initialize();

    //////////
    //Private constructor for internal use only
    Thread(ThreadGroup* g, char* name) ;
	    friend class Runnable;
    static int nlisteners;
    static ThreadListener** listeners;

    //////////
    //<i>No documentation provided</i>
    friend void Thread_send_event(Thread* t, ThreadEvent);
    
    //////////
    //Send events to any  listeners that are watching for thread activity.  Should only be used
    //by the thread implementation.
    static void event(Thread* t, ThreadEvent event) ;

    //////////
    //<i>No documentation provided</i>
    friend void Thread_run(Thread*);

    //////////
    //<i>No documentation proviede</i>
    friend void Thread_shutdown(Thread*);

    //////////
    //<i>No documentation provided</i>
    void run_body();
    class SCICORESHARE ParallelHelper : public Runnable {
	const ParallelBase* helper;
	int proc;
    public:
	ParallelHelper(const ParallelBase* helper, int proc)
	    : helper(helper), proc(proc) {}
	virtual ~ParallelHelper() {}
	virtual void run() {
	    ParallelBase* cheat=(ParallelBase*)helper;
	    cheat->run(proc);
	}
    };

    //////////
    //<i>No documentation provided</i>
    static void check_exit();
    friend class Profiler;
    //////////
    //<i>No documentation provided</i>
    static void profile(FILE* in, FILE* out);
public:
    //////////
    //Create a thread, which will execute the <b>run()</b> method in the <b>runner</b> object.
    //The thread <b>name</b> is used for identification purposes, and does not need to be unique
    //with respect to other threads.  <b>Group</b> specifies the ThreadGroup that to which this
    //thread should belong.  If no group is specified, the default group is used.
    Thread(Runnable* runner, const char* name, ThreadGroup* group=0, bool stopped=false) ;
    
    //////////
    //Return the <b>ThreadGroup</b> associated with this thread.
    ThreadGroup* threadGroup() ;

    //////////
    //Flag the thread as a daemon thread.  When all non-deamon threads exit, the program will exit.
    void setDaemon(bool to=true) ;

    //////////
    //Set the priority for the thread.  Priorities range from 1 to 10, with 10 having the highest
    //priority.  The default priority is 5.
    void setPriority(int priority);
    
    //////////
    //Return the current priority of hte thread.
    int getPriority() const ;
    
    //////////
    //Returns true if the thread is tagged as a daemon thread.
    bool isDaemon() const ;
    
    //////////
    //Arrange to have the thread deleted automatically at exit.  The pointer to the thread should
    //not be used by any other threads once this has been called.
    void detach();

    //////////
    //Returns true if the thread is tagged as a daemon thread
    bool isDetached() const ;

    //////////
    //Kill all threads and exit with <b>code</b>.
    static void exitAll(int code);

    //////////
    //An error occured for a particular thread.  Prin out the message and call <b>nice_abort()</b>
    static void error(char* error) ;

    //////////
    //Returns a pointer to the currently running thread.
    static Thread* currentThread();
 
    //////////
    //Stop the thread.
    void stop();

    //////////
    //Resume the thread
    void resume();

    //////////
    //Blocks the calling thread until this thead has finished executing.  You cannot join detached
    //threads or daemon threads.
    void join();

    //////////
    //Alert this thread. <i>code</i> is passed to the <b>ThreadAlert</b> exception which will get
    //thrown for that thread.
    void alert(int code=0);

    //////////
    //Returns the name of the thread
    const char* threadName() const ;
    
    //////////
    //Returns the number of processors on the system
    static int numProcessors();

    //////////
    //Request that the thread migrate to processor <i>proc</i>.  If <i>proc</i> is -1, then the
    //thread is free to run anywhere.
    void migrate(int proc);

    //////////
    //Returns the private pointer - should only be used by the thread implementation
    Thread_private* getPrivate() const ;

    //////////
    //Topologies for arranging threads on processors, which are used as the <i>topologyHint</i>
    //argument for the <i>parallel</i> methods below.
    enum Topology {
	Linear,
	Ring,
	Square,
	Cube
    };

    //////////
    //Start up several threads that will run in parallel.  A new <b>ThreadGroup</b> is created
    //as a child of the optional parent.  If <i>block</i> is true, theen the caller will block
    //until all of the threads return.  Otherwise, the call will return immediately.
    static ThreadGroup* parallel(const ParallelBase& helper, int nthreads,
				 bool block=false, ThreadGroup* threadGroup=0) ;

    //////////
    //Start up several threads that will run in parallel.  <i>topologyHint</i> defines 
    //a simple mapping of threads to processors, as defined above.  A new <b>ThreadGroup</b> is
    //created as a child of the optional parent.  If <i>block</i> is true, then the caller will
    //block until all of the threads return.  Otherwise, the call will return immediately.
    static ThreadGroup* parallel(const ParallelBase& helper, int nthreads,
				 Topology topologyHint,
				 bool block=false,
				 ThreadGroup* threadGroup=0);

    //////////
    //Start up several threads that will run in parallel.  The library will attempt to arrange the
    //threads for some communications topology, described by the <b>ThreadTopology</b> object.  A
    //new <b>ThreadGroup</b> is created as a child of the optional parent.  
    static ThreadGroup* parallel(const ParallelBase& helper,
				 const ThreadTopology& topologyHint,
				 bool block=false,
				 ThreadGroup* threadGroup=0);

    //////////
    //Return the current system time, in terms of clock ticks.  Time zero is at some undefined point
    //in the past
    static SysClock currentTicks();
    
    //////////
    //Return the current system time, in terms of seconds.  This is slower than currentTicks().  Time
    //zero is at some undefined point in the past.
    static double currentSeconds();

    //////////
    //Return the conversion from seconds to ticks.
    static double ticksPerSecond();

    //////////
    //Return the conversion from ticks to seconds.
    static double secondsPerTick();

    //////////
    //Wait until the specified time in clock ticks.
    static void waitUntil(SysClock ticks);

    //////////
    //Wait until the specified time in seconds.
    static void waitUntil(double seconds);

    //////////
    //Wait for the specified time in clock ticks
    static void waitFor(SysClock ticks);

    //////////
    //Wait for the specified time in seconds
    static void waitFor(double seconds);

    //////////
    //Abort the current thread, or the process.  Prints a message on stderr, and the user may
    //choose one of: <pre>continue(c)/dbx(d)/cvd(v)/kill thread(k)/exit(e)</pre>
    static void niceAbort() ;

    //////////
    //Mark a section as one that could block for debugging purposes.  The <b>int</b> that is
    //returned should be passed into <i>couldBlock(int)</i> when the section has completed.  This
    //will typically not be used outside of the thread implementation
    static int couldBlock(const char* why);

    //////////
    //Mark the end of a selection that could block.  <i>restore</i> was returned from a previous
    //invocation of the above <b>couldBlock</b>.
    static void couldBlock(int restore);
    static void yield();

    //////////
    //<i>No documentation provided</i>
    static void roundRobinPlacement( void *mem, size_t len );
};

#endif








