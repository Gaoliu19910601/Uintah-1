Index: Molecule.xml
===================================================================
--- Molecule.xml	(revision 9265)
+++ Molecule.xml	(working copy)
@@ -5,6 +5,7 @@
     </CXXFLAGS>
     <Files components="V">
       avtMoleculeRenderer.C
+      ParticleInstancingRenderer.C	
       avtOpenGLMoleculeRenderer.C
       avtMesaMoleculeRenderer.C
       avtOpenGLAtomTexturer.C
@@ -17,6 +18,7 @@
     </LIBS>
     <Files components="E">
       avtMoleculeRenderer.C
+      ParticleInstancingRenderer.C	
       avtOpenGLMoleculeRenderer.C
       avtMesaMoleculeRenderer.C
       avtOpenGLAtomTexturer.C
Index: avtOpenGLMoleculeRenderer.C
===================================================================
--- avtOpenGLMoleculeRenderer.C	(revision 9265)
+++ avtOpenGLMoleculeRenderer.C	(working copy)
@@ -69,6 +69,7 @@
 
 #include <avtLookupTable.h>
 #include "avtOpenGLAtomTexturer.h"
+#include "ParticleInstancingRenderer.h"
 
 #include <DebugStream.h>
 #include "matrix.c"
@@ -83,6 +84,8 @@
     #endif
     #include <GL/gl.h>
   #endif
+#else
+  #include <GL/gl.h>
 #endif
 
 #define SHORTEN_BONDS
@@ -106,6 +109,35 @@
 };
  
 
+static GLboolean CheckExtension( char *extName )
+{
+    /*
+     ** Search for extName in the extensions string.  Use of strstr()
+     ** is not sufficient because extension names can be prefixes of
+     ** other extension names.  Could use strtok() but the constant
+     ** string returned by glGetString can be in read-only memory.
+     */
+
+    debug1 << "testing for extension: " << string(extName) << endl;
+
+    char *p = (char *) glGetString(GL_EXTENSIONS);
+    char *end;
+    int extNameLen;
+
+    extNameLen = strlen(extName);
+    end = p + strlen(p);
+
+    while (p < end) {
+	int n = strcspn(p, " ");
+	if ((extNameLen == n) && (strncmp(extName, p, n) == 0)) {
+	    return GL_TRUE;
+	}
+	p += (n + 1);
+    }
+    return GL_FALSE;
+}
+ 
+
 // ****************************************************************************
 //  Constructor: avtOpenGLMoleculeRenderer::avtOpenGLMoleculeRenderer
 //
@@ -273,6 +305,7 @@
 {
     vtkPoints *points = data->GetPoints();
 
+    // cout << "Num Points: " << data->GetNumberOfPoints() << endl;
     vtkDataArray *primary = data->GetPointData()->GetScalars();
     if (!primary)
     {
@@ -382,6 +415,45 @@
         }
     }
 
+    static bool checkForExtensions = true;
+    static bool extensionsSupported = false;
+
+    if (checkForExtensions) {
+	char extnName[128];
+        strcpy(extnName, "GL_EXT_gpu_shader4"); 
+
+        GLboolean extnA = CheckExtension(extnName);
+        if (extnA) {
+            debug1 << "Extension GL_EXT_gpu_shader4 supported" << endl;
+	}
+        else {
+            debug1 << "Extension GL_EXT_gpu_shader4 not supported" << endl;
+	}
+        
+	strcpy(extnName, "GL_EXT_texture_buffer_object"); 
+
+        GLboolean extnB = CheckExtension(extnName);
+        if (extnB) {
+            debug1 << "Extension GL_EXT_texture_buffer_object supported" << endl;
+	}
+        else {
+            debug1 << "Extension GL_EXT_texture_buffer_object not supported" << endl;
+	}
+
+	if (extnA && extnB) {
+	    extensionsSupported = true;
+	    cout << "Necessary extensions supported" << endl;
+	    cout << "VisIt is using the new Molecule plot implementation" << endl;
+	}
+	else {
+	    cout << "Necessary extensions not supported" << endl;
+	    cout << "VisIt is switching to the old Molecule plot implementation" << endl;
+	}
+
+	checkForExtensions = false;
+    }
+
+    if (vmode == 1 || vmode == 2 || (!extensionsSupported)) { // if drawing as imposters
     glBegin(GL_QUADS);
     for (int i=0; i<data->GetNumberOfPoints(); i++)
     {
@@ -475,6 +547,83 @@
         }
     }
     glEnd();
+    }
+    else { // drawing as "real" spheres
+        ParticleInstancingRenderer pirObject;
+	// bool needsRecalculation = true;
+
+	pirObject.SetLiveQualityLevel(atts.GetAtomSphereQuality());
+
+	// if (needsRecalculation) {
+	    pirObject.CleanUp();
+
+	    for (int i=0; i<data->GetNumberOfPoints(); i++)
+	    {
+		int element_number = 0;
+		if (element)
+		    element_number = int(elementnos[i]);
+
+		if (element_number < 0 || element_number > MAX_ELEMENT_NUMBER)
+		    element_number = 0;
+
+		// Determine radius
+		float radius = atts.GetRadiusFixed();
+		if (element && sbar)
+		    radius = atomic_radius[element_number] * radiusscale;
+		else if (element && sbcr)
+		    radius = covalent_radius[element_number] * radiusscale;
+		else if (radiusvar && sbv)
+		    radius = radiusvar[i] * radiusscale;
+
+		unsigned char colorArr[3];
+
+		// Determine color
+		if (color_by_element)
+		{
+		    int level = element_number % numcolors;
+		    memcpy(colorArr, &colors[4*level], 3*sizeof(colorArr)); 
+		}
+		else if (color_by_levels)
+		{
+		    int level = int(scalar[i]) - (primary_is_resseq ? 1 : 0);
+		    if(levelsLUT != 0)
+		    {
+			const unsigned char *rgb = 
+			    levelsLUT->GetLookupTable()->MapValue(level);
+			memcpy(colorArr, rgb, 3*sizeof(colorArr)); ;
+		    }
+		    else
+		    {
+			level = level % numcolors;
+			memcpy(colorArr, &colors[4*level], 3*sizeof(colorArr)); ; 
+		    }
+		}
+		else
+		{
+		    float alpha;
+		    if (varmax == varmin)
+			alpha = 0.5;
+		    else
+			alpha = (scalar[i] - varmin) / (varmax - varmin);
+		    
+		    int color = int((float(numcolors)-.01) * alpha);
+		    if (color < 0)
+			color = 0;
+		    if (color > numcolors-1)
+			color = numcolors-1;
+		    
+		    memcpy(colorArr, &colors[4*color], 3*sizeof(colorArr)); 
+		}
+
+		double *pt = points->GetPoint(i);
+	        pirObject.AddInstancesData(pt, radius, colorArr);  		      
+	    }
+	// }
+
+	// cout << "Added " << pirObject.Size() << " spheres " << sizeof(unsigned char) << endl;  
+
+	pirObject.RenderBatchedInstancing();
+    }
 
     // If we're imposter rendering then enable lighting once more and turn
     // off sphere texturing.
