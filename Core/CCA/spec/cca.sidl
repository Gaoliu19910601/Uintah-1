
package gov.cca {
  /** A tag interface to identify an interface capable of being exported to
      or imported from a CCA component.
      @see Services
  */
  // interface
  interface Port  
    {
      
    }  // end interface Port

  class CCAException extends CIA.Throwable {
  }

  enum DataType {
    None, Int, Long, Float, Double, Fcomplex, Dcomplex, String, Bool,
    IntArray, FloatArray, DoubleArray, FcomplexArray, DcomplexArray,
    StringArray, BoolArray
  };

  class TypeMismatchException extends CCAException {
    DataType getRequestedType();
    DataType getActualType();
  };

  /** A CCA map. */
  interface TypeMap {
    /** Create an exact copy of this Map */
    TypeMap clone();

    /** Create a new Map with no key/value associations. */
    TypeMap cloneEmpty();

    /** Get the value associated with a given key.  If the key
	was not found, return the value dflt. */
    int      getInt(in string key, in int deflt);
    long     getLong(in string key, in long deflt);
    float    getFloat(in string key, in float dflt);
    double   getDouble(in string key, in double dflt);
    fcomplex getFcomplex(in string key, in fcomplex dflt);
    dcomplex getDcomplex(in string key, in dcomplex dflt);
    string   getString(in string key, in string deflt);
    bool     getBool(in string key, in bool dflt);

    array<int>      getIntArray(in string key, in array<int> deflt);
    array<long>     getLongArray(in string key, in array<long> deflt);
    array<float>    getFloatArray(in string key, in array<float> dflt);
    array<double>   getDoubleArray(in string key, in array<double> dflt);
    array<fcomplex> getFcomplexArray(in string key, in array<fcomplex> dflt);
    array<dcomplex> getDcomplexArray(in string key, in array<dcomplex> dflt);
    array<string>   getStringArray(in string key, in array<string> deflt);
    array<bool>     getBoolArray(in string key, in array<bool> dflt);
      
    /** Assign a key and value. Any value previously assigned
	to the same key will be overwritten.  */
    void putInt(in string key, in int value);
    void putLong(in string key, in long value);
    void putFloat(in string key, in float value);
    void putDouble(in string key, in double value);
    void putFcomplex(in string key, in fcomplex value);
    void putDcomplex(in string key, in dcomplex value);
    void putString(in string key, in string value);
    void putBool(in string key, in bool value);

    void putIntArray(in string key, in array<int> value);
    void putLongArray(in string key, in array<long> value);
    void putFloatArray(in string key, in array<float> value);
    void putDoubleArray(in string key, in array<double> value);
    void putFcomplexArray(in string key, in array<fcomplex> value);
    void putDcomplexArray(in string key, in array<dcomplex> value);
    void putStringArray(in string key, in array<string> value);
    void putBoolArray(in string key, in array<bool> value);

    /** Make the key and associated value disappear from the object. */
    void remove (in string key);
    
    /** Getting all the names associated with a particular type
	without exposing the data implementation details.  The keys
	will be returned in an arbitrary order. If type specified is
	None (no specification) all keys of all types are returned.
    */
    array<string> getAllKeys(in DataType t);
    
    /** Return true if the key exists in this map */
    bool hasKey(in string key);
    
    /** Return the type of the value associated with this key */
    DataType typeOf(in string key);

  }  // end interface TypeMap

  /** An opaque reference to a Component. */
  // interface
  interface ComponentID  
    {

      /** Produce a string that, within the current
	  framework, that uniquely defines this component reference
	  within all possible frameworks.
	  For parallel programming, this string will likely be different
	  by a processor/process/thread id across the cohort of a 
	  single "spmd instance".

	  @return  The unique identifier (which is necessarily pretty 
	  gorey looking) for this component. toString is probably a 
	  bad choice of name for this method as toString is likely to 
	  be used in a more Java-conventional sense.
      */
      string toString() ;

    }  // end interface ComponentID

  /** The handle through which the component communicates with its
      containing context and (indirectly) other components. 
  */
  interface Services {
    
    /** Fetch a previously registered Port (defined by either 
	addProvidePort or (more typically) registerUsesPort).  
	@return Will return the Port (possibly waiting forever while
	attempting to acquire it) or throw an exception. Does not return
	NULL, even in the case where no connection has been made. 
	If a Port is returned,
	there is then a contract that the port will remain valid for use
	by the caller until the port is released via releasePort(), or a 
	Disconnect Event is successfully dispatched to the caller,
	or a runtime exception (such as network failure) occurs during 
	invocation of some function in the Port. 
	<p>
	Subtle interpretation: If the Component is not listening for
	Disconnect events, then the framework has no clean way to
	break the connection until after the component calls releasePort.
	</p>
	<p>The framework may go through some machinations to obtain
	the port, possibly involving an interactive user or network 
	queries, before giving up and throwing an exception.
	</p>
	  
	@param name The previously registered or provide port which
	the component now wants to use.
	@exception CCAException with the following types: NotConnected, PortNotDefined, NetworkError, OutOfMemory.
	  
    */
    Port getPort(in string portName) throws CCAException ;
      
    /** Get a previously registered Port (defined by
	either addProvide or registerUses) and return that
	Port if it is available immediately (already connected
	without further connection machinations).
	There is an contract that the
	port will remain valid per the description of getPort.
	@return The named port, if it exists and is connected or self-provided,
	or NULL if it is registered and is not yet connected. Does not
	return if the Port is neither registered nor provided, but rather
	throws an exception.
	@param name registered or provided port that
	the component now wants to use.
	@exception CCAException with the following types: PortNotDefined, OutOfMemory.
    */
    Port getPortNonblocking(in string name) throws CCAException ;
      
    /** Notifies the framework that this component is finished 
	using the previously fetched Port that is named.     
	The releasePort() method calls should be paired with 
	getPort() method calls; however, an extra call to releasePort()
	for the same name may (is not required to) generate an exception.
	Calls to release ports which are not defined or have never be fetched
	with one of the getPort functions generate exceptions.
	@param name The name of a port.
	@exception CCAException with the following types: PortNotDefined, PortNotInUse.
    */
    void releasePort(in string name) throws CCAException ;
      
    /** Creates a StringMap, potentially to be used in subsequent
	calls to describe a Port.  The StringMap is initially null.
    */
    TypeMap createTypeMap() throws CCAException ;

    /** Register a request for a Port that will be retrieved subsequently 
	with a call to getPort().
	@param name A string uniquely describing this port.  This string
	must be unique for this component, over both uses and provides ports.
	@param type A string desribing the type of this port.
	@param properties A TypeMap describing optional properties
	associated with this port. This can be a null pointer, which
	indicates an empty list of properties.  Properties may be
	obtained from createTypeMap or any other source.
	In these properties, all frameworks recognize at least the
	following keys and values in implementing registerUsesPort:
	<pre>
	key:              standard values (in string form)     default
	"MAX_CONNECTIONS" any nonnegative integer, "unlimited".   1
	"MIN_CONNECTIONS" any integer > 0.                        0
	"ABLE_TO_PROXY"   "true", "false"                      "false"
	</pre>
	The component is not expected to work if the framework
	has not satisfied the connection requirements.
	The framework is allowed to return an error if it
	is incapable of meeting the connection requirements,
	e.g. it does not implement multiple uses ports.
	The caller of registerUsesPort is not obligated to define
	these properties. If left undefined, the default listed above is
	assumed.
	@exception CCAException with the following types: PortAlreadyDefined, OutOfMemory.
    */
    void registerUsesPort(in string name, in string type,
			  in TypeMap properties) throws CCAException ;
      
    /** Notify the framework that a Port, previously registered by this
	component but currently not in use, is no longer desired. 
	Unregistering a port that is currently 
	in use (i.e. an unreleased getPort() being outstanding) 
	is an error.
	@param name The name of a registered Port.
	@exception CCAException with the following types: UsesPortNotReleased, PortNotDefined.
    */
    void unregisterUsesPort(in string name) throws CCAException ;

    /** Exposes a Port from this component to the framework.  
	This Port is now available for the framework to connect 
	to other components. 
	@param inPort An interface (tagged with CCA-ness
	by inheriting from gov.cca.Port) the framework will
	make available to other components.
	@param name A string uniquely describing this port.  This string
	must be unique for this component, over both uses and provides ports.
	@param type A string desribing the type of this port.
	@param properties A TypeMap describing optional properties
	associated with this port. This can be a null pointer, which
	indicates an empty list of properties.  Properties may be
	obtained from createTypeMap or any other source.
	In these properties, all frameworks recognize at least the
	following keys and values in implementing registerUsesPort:
	<pre>
	key:              standard values (in string form)     default
	"MAX_CONNECTIONS" any nonnegative integer, "unlimited".   1
	"MIN_CONNECTIONS" any integer > 0.                        0
	"ABLE_TO_PROXY"   "true", "false"                      "false"
	</pre>
	The component is not expected to work if the framework
	has not satisfied the connection requirements.
	The framework is allowed to return an error if it
	is incapable of meeting the connection requirements,
	e.g. it does not implement multiple uses ports.
	The caller of addProvidesPort is not obligated to define
	these properties. If left undefined, the default listed above is
	assumed.
	@exception CCAException with the following types: PortAlreadyDefined, OutOfMemory.
    */
    void addProvidesPort(in Port inPort, in string
			 name, in string type, in TypeMap properties) throws CCAException ;

    /** Returns the complete list of the properties for a Port.  This
	includes the properties defined when the port was registered
	(these properties can be modified by the framework), two special
	properties "cca.portName" and "cca.portType", and any other
	properties that the framework wishes to disclose to the component.
    */
    TypeMap getPortProperties(in string name) ;
  
    /** Notifies the framework that a previously exposed Port is no longer 
	available for use. The Port being removed must exist
	until this call returns, or a CCAException may occur.
	@param name The name of a provided Port.
	@exception PortNotDefined. In general, the framework will not dictate when the component
	chooses to stop offering services.
    */
    void removeProvidesPort(in string name) throws CCAException ;

    /** Get a reference interface for the component to which 
	this Services object belongs.
	@return The ComponentID uniquely paired with this component.
    */
    ComponentID getComponentID() ;

  }  // end interface Services

  /** The CCA object model: the interface that all CCA components must implement. */
  // abstract interface
  interface Component  
    {


      /** Obtain Services handle, through which the component and framework communicate.  
	  This is the one method that every CCA Component must implement. 
	  Every component must also implement a NULL constructor.
      */
      void setServices(in Services svc) ;

    }  // end interface Component


  interface Framework {
    Services createServices(in string name);
  }

  /** A do-it port.  Tremendously useful. Provided by components 
      to advertise that they can do some arbitrary thing. 
      A component may provide more than one of these under
      different names (via delegation). More detailed forms
      of this include TimeAdvance, etc.
  */
  // interface
  interface GoPort  extends Port
    {  


      /** Make the component do its thing.
       * @return
       * <ul>
       * <li> 0 if did ok</li>
       * <li> -1 if had problem,</li>
       * <li> -2 if had problem bad enough to shoot
       *  the component in the head or exit the framework.</li> 
       * </ul>
       */
      int go() ;

    }  // end interface GoPort

  /** There are 4 basic events to do with connections. They form
     a subset of the events in the component lifecycle. */
  enum Type {
  /** never delivered to a listener, but used by listeners to subscribe broadly. */
  ALL = 0, 

  /** a connection may soon be made. */
  ConnectPending = 1, 

  /** a connection has been made. */
  Connected = 2,

  /** a connection will soon be broken. */
  DisconnectPending = 3,
 
  /** a connection has been broken. */
  Disconnected = 4,
  } // end enum 

/** Base event interface components wishing to know about their connectedness
(used or provided ports) must listen for. 
This interface represents a large simplification and callback
style imposed over the general EventService layer.
This interface contains only enough information to be useful
in the scope of the particular Component instance receiving
the event.
*/
// interface
interface ConnectionEvent 
{


  /** Returns the integer from those defined above
      in Type that describes the connection event.
      At present there are 4 of these.
      <p>
      The semantics are noted before
      each member of the enum/static constant. We can add in different
      types of connect/disconnect as multiports and
      explicit local/global/sync/async semantics are agreed to in the future.
      </p>

      <p>
      At present we assume that:
      <ul>
      <li> all instances in a component cohort (often thought of as a single
        "parallel component") receive all the events
        and in the same order, but not necessarily globally synchronously.</li>
      <li> for disconnections, within a process the events are delivered first
        to the using component then to the providing component.</li>
      <li> for connections, within a process the events are delivered first
        to the providing component then to the using component.</li>
      </ul>

      Clearly some of the assumptions above may not suit a component
      instance in which multiple execution threads act on a
      single instance of the gov::cca::Services object (SMP). The Services
      specification is ambiguous as to whether such a component is even allowed.
      When this is clarified, additional members of the enum may arise,
      in which case the assumptions here apply only to
      ConnectPending, Connected, DisconnectPending, Disconnected types.

  */
  Type getEventType() ;

   /** Get the Properties of the affected Port. */
  TypeMap getPortProperties() ;

}  // end interface ConnectionEvent
/** This is the interface that a component must provide
in order to be notified of ConnectionEvents. */
// interface
interface ConnectionEventListener 
{

  /** Delivered to listeners when a connection is made or broken. */
   void connectionActivity(in ConnectionEvent evt) ;

}  // end interface ConnectionEventListener

/** A callback service to alert a component when connections are made 
    or broken; this service is to be 
    immediately available during a setServices call. This service 
    interface is compatible with a direct-connected or proxy framework.
    @see Component 
*/
// interface
interface ConnectionEventService  extends Port
{
  /** Sign up to be told about connection activity.
      @param connectionEventType must be one of the integer values 
             ALL, ConnectPending, Connected, DisconnectPending, Disconnected
             as defined in @see ContainerEventType. 
             ALL means listening to all of the other four listed here.
      @param l, an object (this component or its delegate) that listens
             by implementing the ConnectionEventListener callback.
   */
   void addConnectionEventListener(in Type type, in ConnectionEventListener l) ;

  /** Ignore future ConnectionEvents of the given type.
      Removing a non-added listener is not an error. 
      @param connectionEventType must be one of the integer values defined in
             addConnectionEventListener.
      @param l, a previously added listener interface.
   */
   void removeConnectionEventListener(in Type type, in ConnectionEventListener l) ;
}  // end interface ConnectionEventService


  interface BuilderService extends Port {
    ComponentID createComponentInstance(in string name, in string type);
    void connect(in ComponentID c1, in string port1,
		 in ComponentID c2, in string port2);
  }

interface ComponentRegistry extends Port {
  array<ComponentDescription> listAllComponentTypes();
}
interface ComponentDescription {
  string getType();
  string getModelName();
}

// Builder events
// Component created
// Component destroyed
// Component moved
// Connection created
// Connection destroyed
// Connection moved
enum ComponentEventType {
  AllComponentEvents = 0,
  InstantiatePending=1,
  ComponentInstantiated=2,
  DestroyPending=3,
  ComponentDestroyed=4,
  ComponentMoved=5,
}
interface ComponentEventListener {
  void componentActivity(in ComponentEvent evt);
}
interface ComponentEvent {
  ComponentEventType getEventType() ;

  ComponentID getComponentID();

   /** Get the Properties of the affected Port. */
  TypeMap getComponentProperties() ;
}
interface ComponentEventService  extends Port
{
  /** Sign up to be told about connection activity.
      @param connectionEventType must be one of the integer values 
             ALL, ConnectPending, Connected, DisconnectPending, Disconnected
             as defined in @see ContainerEventType. 
             ALL means listening to all of the other four listed here.
      @param l, an object (this component or its delegate) that listens
             by implementing the ConnectionEventListener callback.
  */
   void addComponentEventListener(in ComponentEventType type, in ComponentEventListener l, in bool playInitalEvents);

  /** Ignore future ConnectionEvents of the given type.
      Removing a non-added listener is not an error. 
      @param connectionEventType must be one of the integer values defined in
             addConnectionEventListener.
      @param l, a previously added listener interface.
   */
   void removeComponentEventListener(in ComponentEventType type, in ComponentEventListener l) ;

   void moveComponent(in ComponentID component, in int x, in int y);
}
}
