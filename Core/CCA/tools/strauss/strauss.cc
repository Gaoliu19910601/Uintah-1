/*
  The contents of this file are subject to the University of Utah Public
  License (the "License"); you may not use this file except in compliance
  with the License.
  
  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations under
  the License.
  
  The Original Source Code is SCIRun, released March 12, 2001.
  
  The Original Source Code was developed by the University of Utah.
  Portions created by UNIVERSITY are Copyright (C) 2001, 1994 
  University of Utah. All Rights Reserved.
*/
 

#include <algorithm>
#include <iostream>
#include <map>
#include <sstream>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>

#include <Dataflow/XMLUtil/StrX.h>
#include <Dataflow/XMLUtil/XMLUtil.h>

#include <Core/CCA/tools/strauss/strauss.h>

using namespace std;
using namespace SCIRun;


//SState is used a container to emit code into
struct Leader {
};

struct SState : public std::ostringstream {
  std::string leader;
  std::string push_leader() {
    string oldleader=leader;
    leader+="  ";
    return oldleader;
  }
  void pop_leader(const std::string& oldleader) {
    leader=oldleader;
  }
  friend std::ostream& operator<<(ostream& out, const Leader&);
};

std::ostream& operator<<(SState& out, const Leader&) {
  out << out.leader;
  return out;
}
//**** End of SState


Strauss::Strauss(string& plugin, string& portspec, 
		 string& header, string& impl)
  :header(header), impl(impl), plugin(plugin), 
   portSpec(portspec), fHeader(header.c_str()), fImpl(impl.c_str())
{
  if((!fHeader)||(!fImpl)) {
    cerr << "ERROR in: ./strauss/main.cc: Couldn't open output file\n";
    exit(1);
  }
  
  //Set up XML Parser
  pluginParser.setDoValidation(false);
  pluginParser.setErrorHandler(&handler);
  portParser.setDoValidation(false);
  portParser.setErrorHandler(&handler);
  pluginParser.parse(plugin.c_str());
  portParser.parse(portspec.c_str());

  //Create name the bridge component class
  ostringstream o;
  srand(time(NULL));
  o << "Bridge" << 1+(int)(1000.0*rand()/(RAND_MAX+1.0));
  bridgeComponent = o.str();

  //Init Ruby
  ruby = RubyEval::instance();

  cout << "Strauss constructor\n";
}

Strauss::~Strauss()
{
  fHeader.close();
  fImpl.close();
}

void Strauss::emitHeader()
{
  SState hdr;
  int n;

  hdr << "//This file was automatically generated by Strauss. Do not edit directly!!\n";
  hdr << "\n";
  hdr << "#ifndef STRAUSS_GENERATED_" << header.substr(0,header.length()-2) << "\n";
  hdr << "#define STRAUSS_GENERATED_" << header.substr(0,header.length()-2) << "\n";
  hdr << "\n";
  n = readXML(pluginParser.getDocument(),"n:includeFile");
  for(int i=0;i<n;i++){
    hdr << "#include " << scratch[i] << "\n";
  }
  hdr << "\n";
  hdr << "#include <SCIRun/Bridge/BridgeComponent.h>\n";
  hdr << "#include <SCIRun/Bridge/BridgeServices.h>\n";
  hdr << "\n";
  hdr << "using namespace std;\n";
  hdr << "\n";
  int n_nspc = readXMLChildNode(pluginParser.getDocument(),"n:BridgeComponent","n:namespace");
  for(int i=0;i<n_nspc;i++){
    hdr << "namespace " << scratch[i] << " {\n";
  }
  hdr << "  class " << bridgeComponent << " : public BridgeComponent{\n";
  hdr << "  public:\n";
  hdr << "    " << bridgeComponent << "();\n";
  hdr << "    virtual ~" << bridgeComponent << "();\n";
  hdr << "    virtual void setServices(const BridgeServices* svc);\n";
  emitMethodSignatures(hdr,pluginParser.getDocument(),"n:bcMethod");
  hdr << "  private:\n";
  hdr << "    " << bridgeComponent << "(const " << bridgeComponent << "&);\n";
  hdr << "    " << bridgeComponent << "& operator=(const " << bridgeComponent << "&);\n";
  hdr << "    BridgeServices* services;\n";
  hdr << "  };\n";
  for(int i=0;i<n_nspc;i++){
    hdr << "} //end of namespace\n";
  }
  hdr << "\n";
   
  emitProvidesPortSpec(hdr,pluginParser.getDocument());

  hdr << "#endif\n";

  fHeader << hdr.str();
}


void Strauss::emitImpl()
{
  SState impl;
  int n;

  impl << "//This file was automatically generated by Strauss. Do not edit directly!!\n";
  impl << "\n";
  impl << "#include \"Bridge.h\"\n";
  impl << "\n";

  //emit using namespaces 
  int n_nspc = readXMLChildNode(pluginParser.getDocument(),"n:BridgePort","n:namespace");
  for(int i=0;i<n_nspc;i++){
    if(i==0) impl << "using namespace ";
    impl << scratch[i];
    (i<(n_nspc-1)) ?impl<<"::" :impl<<";\n";
  }
  n_nspc = readXMLChildNode(pluginParser.getDocument(),"n:BridgeComponent","n:namespace");
  for(int i=0;i<n_nspc;i++){
    if(i==0) impl << "using namespace ";
    impl << scratch[i];
    (i<(n_nspc-1)) ?impl<<"::" :impl<<";\n";
  }
  readXMLAttr(portParser.getDocument(),"n:package","name");
  impl << "using namespace " << scratch[0] << ";\n";

  impl << "using namespace SCIRun;\n";
  impl << "using namespace std;\n\n";

  //make component function 
  impl << "extern \"C\" BridgeComponent* make_Bridge_" << bridgeComponent << "()\n";
  impl << "{\n";
  impl << "  return static_cast<BridgeComponent*>(new " << bridgeComponent << "());\n";
  impl << "}\n\n";

  //TOPCODE:
  n = readXMLChildNode(pluginParser.getDocument(),"n:topLevel","n:code");
  for(int i=0;i<n;i++){
    impl << scratch[i];
  }

  //Constructor  
  impl << bridgeComponent << "::" << bridgeComponent << "(){\n";
  n = readXMLChildNode(pluginParser.getDocument(),"n:BridgeComponent","n:constructorCode");
  for(int i=0;i<n;i++){
    impl << scratch[i];
  }
  impl << "}\n\n";

  //Destructor
  impl << bridgeComponent << "::~" << bridgeComponent << "(){\n";
  n = readXMLChildNode(pluginParser.getDocument(),"n:BridgeComponent","n:destructorCode");
  for(int i=0;i<n;i++){
    impl << scratch[i];
  }
  impl << "}\n\n";

  //SETSERVICES:
  impl << "void " << bridgeComponent << "::setServices(const BridgeServices* svc) {\n";
  impl << "  services=const_cast<BridgeServices*>(svc);\n"; 

  //top level code
  n = readXMLChildNode(pluginParser.getDocument(),"n:setServices","n:code");
  for(int i=0;i<n;i++){
    impl << scratch[i];
  }

  //add provides port
  n = readXMLChildNode(pluginParser.getDocument(),"n:setServices","n:registerUsesPort");
  for(int i=0;i<n;i++){
    impl << scratch[i];
  }

  //registerusesport
  n = readXMLChildNode(pluginParser.getDocument(),"n:setServices","n:addProvidesPort");
  for(int i=0;i<n;i++){
    impl << scratch[i];
  }

  impl << "}\n\n";
  //EOF SETSERVICES

  //COMPONENT METHODS:
  emitMethod(impl,pluginParser.getDocument(),"n:bcMethod",bridgeComponent);

  //PORTPORTPORTPORTPORTPORT
  readXMLAttr(portParser.getDocument(),"n:port","name");
  string pclassName = scratch[0];

  //PORT Constructor
  n_nspc = readXMLChildNode(pluginParser.getDocument(),"n:BridgePort","n:namespace");
  for(int i=0;i<n_nspc;i++){
    impl << scratch[i] << "::";
  }
  impl << pclassName << "::" << pclassName << "(){\n";
  n = readXMLChildNode(pluginParser.getDocument(),"n:BridgePort","n:constructorCode");
  for(int i=0;i<n;i++){
    impl << scratch[i];
  }
  impl << "}\n\n";

  //PORT Destructor
  n_nspc = readXMLChildNode(pluginParser.getDocument(),"n:BridgePort","n:namespace");
  for(int i=0;i<n_nspc;i++){
    impl << scratch[i] << "::";
  }
  impl << pclassName << "::~" << pclassName << "(){\n";
  n = readXMLChildNode(pluginParser.getDocument(),"n:BridgePort","n:destructorCode");
  for(int i=0;i<n;i++){
    impl << scratch[i];
  }
  impl << "}\n\n";

  //OTHER PORT METHODS:
  emitMethod(impl,pluginParser.getDocument(),"n:bpMethod",pclassName);

  //PORT METHODS:
  emitPortMethod(impl,portParser.getDocument(),"n:method"); 

  fImpl << impl.str();
}


//******* PRIVATE METHODS: **********

void Strauss::emitProvidesPortSpec(SState& hdr, DOMDocument* pSpec)
{
  int n;
  string nspace;

  int n_nspc = readXMLChildNode(pSpec,"n:BridgePort","n:namespace");
  for(int i=0;i<n_nspc;i++){
    hdr << "namespace " << scratch[i] << " {\n";
  }

  readXMLAttr(portParser.getDocument(),"n:port","name");
  string pclassName = scratch[0];

  hdr << "  class " << pclassName << " ";

  n = readXML(pSpec,"n:extendsClass");
  for(int i=0;i<n;i++) {
    if(i==0) hdr << ": public ";
    hdr << scratch[i];
  }
  hdr << "{\n";
  hdr << "  public:\n";
  //Constructor
  hdr << "    " << pclassName << "();\n";
  //Destructor
  hdr << "    ~" << pclassName << "();\n";
  //Other methods
  emitMethodSignatures(hdr,pluginParser.getDocument(),"n:bpMethod");
  emitMethodSignatures(hdr,portParser.getDocument(),"n:method");
  
  hdr << "    ::SCIRun::BridgeServices* mysvcs;\n";  
  hdr << "  };\n\n";

  for(int i=0;i<n_nspc;i++){
    hdr << "} //end of namespace\n";
  }
  hdr << "\n";
}

void Strauss::emitMethodSignatures(SState& hdr, DOMDocument* doc, string tagname)
{
  scratch.clear();
  string mname;
  string rettype;

  DOMNodeList* tlist = doc->getElementsByTagName(to_xml_ch_ptr(tagname.c_str()));
  int ntlist = tlist->getLength();
  for(int i=0;i<ntlist;i++){
    DOMNode* d = tlist->item(i);
    DOMNode* name = d->getAttributes()->getNamedItem(to_xml_ch_ptr("name"));
    mname = xmlto_string(name->getNodeValue());
    name = d->getAttributes()->getNamedItem(to_xml_ch_ptr("retType"));
    rettype = xmlto_string(name->getNodeValue());
   
    int n = rec_readXMLChildNode(d, "n:argument"); 

    hdr << "    " << rettype << " " << mname << "("; 
    for(int i=0;i<n;i++) {
      hdr << scratch[i]; 
      if(i < n-1) hdr << ",";
    }
    hdr << ");\n";
  }
}

void Strauss::emitMethod(SState& out, DOMDocument* doc, string tagname, string objname)
{
  scratch.clear();
  string mname;
  string rettype;
  int n;

  DOMNodeList* tlist = doc->getElementsByTagName(to_xml_ch_ptr(tagname.c_str()));
  int ntlist = tlist->getLength();
  for(int i=0;i<ntlist;i++){
    DOMNode* d = tlist->item(i);
    DOMNode* name = d->getAttributes()->getNamedItem(to_xml_ch_ptr("name"));
    mname = xmlto_string(name->getNodeValue());
    name = d->getAttributes()->getNamedItem(to_xml_ch_ptr("retType"));
    rettype = xmlto_string(name->getNodeValue());

    n = rec_readXMLChildNode(d, "n:argument");
    out << rettype << " " << objname << "::" << mname << "(";
    for(int i=0;i<n;i++) {
      out << scratch[i];
      if(i < n-1) out << ",";
    }
    out << ") {\n";

    scratch.clear();
    n = rec_readXMLChildNode(d, "n:code");
    for(int i=0;i<n;i++) {
      out << scratch[i];
    }
    out << "}\n\n";
  }
}

void Strauss::emitPortMethod(SState& out, DOMDocument* doc, string tagname)
{
  scratch.clear();
  string mname;
  string rettype;
  int n;

  DOMNodeList* tlist = doc->getElementsByTagName(to_xml_ch_ptr(tagname.c_str()));
  int ntlist = tlist->getLength();
  for(int i=0;i<ntlist;i++){
    DOMNode* d = tlist->item(i);
    DOMNode* name = d->getAttributes()->getNamedItem(to_xml_ch_ptr("name"));
    mname = xmlto_string(name->getNodeValue());
    name = d->getAttributes()->getNamedItem(to_xml_ch_ptr("retType"));
    rettype = xmlto_string(name->getNodeValue());

    readXMLChildNode(pluginParser.getDocument(),"n:BridgePort","n:namespace");
    string pNamespc = scratch[0];
    readXMLAttr(portParser.getDocument(),"n:port","name");
    string pclassName = scratch[0];

    scratch.clear();
    n = rec_readXMLChildNode(d, "n:argument");
    out << rettype << " " << pNamespc << "::" << pclassName << "::" << mname << "(";
    for(int i=0;i<n;i++) {
      out << scratch[i];
      if(i < n-1) out << ",";
    }
    out << ") {\n";

    n = readXMLChildNode(pluginParser.getDocument(), "n:portMethods", "n:code");
    for(int i=0;i<n;i++) {
      out << scratch[i];
    }
    out << "}\n\n";
  }
}

int Strauss::readXML(DOMDocument* doc, string tag)
{
  cerr << "NOW = " << tag << "\n";

  scratch.clear();

  DOMNodeList* tlist = doc->getElementsByTagName(to_xml_ch_ptr(tag.c_str()));
  int ntlist = tlist->getLength();
  for(int i=0;i<ntlist;i++){
    DOMNodeList* list = tlist->item(i)->getChildNodes();
    int nlist = list->getLength();
    for(int j=0;j<nlist;j++) { 
      DOMNode* d = list->item(j);
      isScriptScratch(xmlto_string(d->getNodeValue()));
    }
  }
  
  return (scratch.size());
}

int Strauss::readXMLAttr(DOMDocument* doc, string tag, string attr)
{
  int nlist;

  scratch.clear();
  DOMNodeList* list = doc->getElementsByTagName(to_xml_ch_ptr(tag.c_str()));
  nlist = list->getLength();

  for(int i=0;i<nlist;i++){
    DOMNode* d = list->item(i);
    DOMNode* name = d->getAttributes()->getNamedItem(to_xml_ch_ptr(attr.c_str()));
    isScriptScratch(xmlto_string(name->getNodeValue()));
  }
  
  return (scratch.size());
}

int Strauss::readXMLChildNode(DOMDocument* doc, string parent, string child)
{
  int nlist;

  cerr << "NOW = " << parent << "::" << child << "\n";

  scratch.clear();
  DOMNodeList* list = doc->getElementsByTagName(to_xml_ch_ptr(parent.c_str()));
  nlist = list->getLength();
  //Only one parent node in document is allowed
  if(nlist < 1) return 0;
  assert(nlist == 1);

  DOMNode* cursor = list->item(0);
  return rec_readXMLChildNode(cursor->getFirstChild(),child);
}

int Strauss::rec_readXMLChildNode(DOMNode* cursor, string child) 
{
  if(cursor == NULL) return 0;
  if(xmlto_string(cursor->getNodeName()) == child) {
    //found a child
    DOMNodeList* xlist = cursor->getChildNodes();
    int nxlist = xlist->getLength();
    for(int i=0;i<nxlist;i++){
      DOMNode* d = xlist->item(i);
      isScriptScratch(xmlto_string(d->getNodeValue()));
    }
    nxlist += rec_readXMLChildNode(cursor->getNextSibling(),child);
    return (scratch.size()); 
  }

  //recursively call myself on children
  int ch = 0;
  if(cursor->hasChildNodes()) 
    ch = rec_readXMLChildNode(cursor->getFirstChild(),child);

  ch += rec_readXMLChildNode(cursor->getNextSibling(),child);
  return (scratch.size());
}

void Strauss::isScriptScratch(std::string line)
{
  int p = 0;
  int len = line.length();
  char* scratchfile = "/home/sci/damevski/SCIRun/ccadebug-RH8/Core/CCA/tools/strauss/scratchfile"; 

  //is it an embedded ruby script
  p = line.find("eval(");
  if(p != ::std::string::npos) {
    ::std::string script = line.substr(p+5,len-(p+5+1));
    ::std::cerr << "eval ruby script... -" << script << "-\n";
    string rubret = ruby->strval2str(ruby->eval(script.c_str()));
    scratch.push_back(rubret);
    return;
  }

  //is it an reference to a ruby file 
  p = line.find("file(");
  if(p != ::std::string::npos) {
    int bufsize=512;
    char *buf=new char[bufsize];
    ::std::string fname = line.substr(p+5,len-(p+5+1)); 
    ::std::cerr << "load ruby file... -" << fname << "-\n"; 
    ofstream osfile(scratchfile);
    osfile << portSpec << "\n";  
    osfile.close();

    ruby->run_file(fname.c_str());

    ifstream isfile(scratchfile);
    while(!isfile.eof()) {
      isfile.getline(buf,bufsize-1); 
      string sbuf(buf); 
      sbuf += "\n";
      scratch.push_back(sbuf);
    }
    isfile.close();
    return;
  }
  
  //just a string 
  scratch.push_back(line);
}
