// SIDL interface descriptions of CCA and implementations.
//
// The one disturbing property of this is that Babel.Object or equivalent
// makes an appearance, as you would expect. Not surprisingly,
// this is in the ConnectionEvent interface.
// We haven't yet escaped completely from framework dependence
// if we believe in events.
//
// This could be the source for
// specifying (or at least generating) all the language bindings.

//=============================================================================
//  The ports/services spec itself
//=============================================================================
package CCA {

  /** Framework-specific interfaces 
      (that may make components unportable across frameworks)
  */
  class FrameworkSpecific_Object; // externally defined Object/void *
  class FrameworkSpecific_Event {}; // externally defined event object class

  class ConnectionEvent extends FrameworkSpecific_Event {
    void setSource(in FrameworkSpecific_Object source);
    FrameworkSpecific_Object getSource();
  };

  interface ConnectionListener{
     void connectionActivity(in ConnectionEvent evt);
  };



  /** Framework-independent CCA interfaces
   */
  interface Port {
     /// just an inheritance stub. Which seems to be in question again.
  };


  interface ProvidesPort extends Port {
    // base class for a provides gport.
  };


  interface UsesPort extends Port {
    void addProvidesPort(in ProvidesPort p);
    void removeProvidesPort(in ProvidesPort p);
  };


  interface PortInfo{
    string getType();
    string getName();
    void setType(in string type);
    void setName(in string name);

    // part of a reference implementation
    string toString();
  };


  interface Services {

     array<PortInfo,1> getProvidesPorts();
     array<PortInfo,1> getUsesPorts();
     Port getPort(in string name); 

     void registerUsesPort(in PortInfo name_and_type);
     void addProvidesPort(in ProvidesPort inPort, in PortInfo name);
     void addConnectionListener(in ConnectionListener l);

     void releasePort(in string name); // different arguments needed?
  };


  interface Component {

    void setServices(in Services cc);
    Services getServices();
  };

}; // end package CCA




//=============================================================================
//  the description of a PortInfo implementation and CCAServices
//=============================================================================
package Default { // default (reference) of CCA.PortInfo 

  class PortInfo implements CCA.PortInfo {
    /// Implements in the most generic way the PortInfo interface.
    string getType();
    string getName();

    void setType(in string type);
    void setName(in string name);
    void copyPortInfo(in PortInfo p);

    // part of a reference implementation
    string toString();
  };


  class Gizzard implements CCA.Services {

    array<CCA.PortInfo,1> getUsesPorts();
    array<CCA.PortInfo,1> getProvidesPorts();
    void registerUsesPort(in CCA.PortInfo name_and_type);
    void addProvidesPort(in CCA.ProvidesPort inPort, in CCA.PortInfo name);
    CCA.Port getPort(in string name);
    void releasePort(in string name);
    void addConnectionListener(in CCA.ConnectionListener l);
  
  
    // Below here these methods are unavailable to the components
    // contained by our framework. 

    void fireConnectionListeners(in CCA.ConnectionEvent evt);
     /// Fire the listeners with a an event.
  
    /** This is how the framework adds a UsesPort.  Note that this is
        completely inaccessible from the component. */
    void addUsesPort(in CCA.PortInfo info, in CCA.UsesPort up);

    /** Answer with the UsesPort's that have been registered by the
        component holding this CCAServices object. */
    array<string,1> getUsesPortRegister();
  
  };
}; // end package Default (reference implementation description)


//=============================================================================
//  the description of one way to do a direct-connect framework
//=============================================================================
package DirectConnect {

  interface Port extends CCA.ProvidesPort, CCA.UsesPort, CCA.Port {
  };
 
  interface DefaultPort extends Port {
    void addProvidesPort(in CCA.ProvidesPort p);
    void removeProvidesPort(in CCA.ProvidesPort p);
  };
};

package Go {

  interface ProvidesPort extends CCA.UsesPort {  
    void go();
  };

  interface UsesPort extends CCA.UsesPort {  
    void go();
  };

  interface DirectPort extends ProvidesPort, UsesPort, CCA.Port {
    void go();
  };
};


//=============================================================================
//  a batch of direct-connect interfaces in the funny triangle pattern
//=============================================================================
package StringConsumer {

  interface ProvidesPort extends CCA.ProvidesPort {
    void setString(in string s);
  };

  interface UsesPort extends CCA.UsesPort {
    void setString(in string s);
  };

  interface DirectPort extends DirectConnect.DefaultPort, ProvidesPort, UsesPort {
    void setString(in string s);
  };
};

package TimeProducer {

  interface ProvidesPort extends CCA.ProvidesPort {
    string getTime();
  };

  interface UsesPort extends CCA.UsesPort {
    string getTime();
  };

  interface DirectPort extends ProvidesPort, UsesPort, DirectConnect.Port {
    string getTime();
  };

};

package DoubleArrayProducer {
  interface ProvidesPort extends CCA.ProvidesPort {
    array<double,1> getArray();
  };

  interface UsesPort extends CCA.UsesPort {
    array<double,1> getArray();
  };

  interface DirectPort extends DirectConnect.DefaultPort,
                               ProvidesPort,
                               UsesPort {
    array<double,1> getArray();
  };
};




//=============================================================================
//  descriptions of several implementations of direct-connects
//=============================================================================
package ExampleComponents {

  class StarterComponent implements DirectConnect.DefaultPort, CCA.Component, Go.DirectPort {
    void setServices(in CCA.Services cc);
    CCA.Services getServices();
    void go();
  };

  class TimeStamper implements CCA.Component, StringConsumer.DirectPort {
    void setCCAServices(in CCA.Services cc);
    CCA.Services getServices();
    void setString(in string s);
  };

  class Timer implements DirectConnect.DefaultPort,
                         CCA.Component,
                         TimeProducer.DirectPort {
    void setServices(in CCA.Services svc);
    CCA.Services getServices();
    string getTime();
  };

};  // end package ExampleComponents






//=============================================================================
//  a slice of the ESI pie, for the sake of argument.
//=============================================================================
package ESI {

  interface Map{};
  interface MapAlgebraic extends Map {};

  interface Vector {
    int clone(out Vector createdVector);
    int getMap(out Map map);
    int put(in double scalar);
    int scale(in double scalar);
    int norm1(out double n1);
    int norm2(out double n2);
    int norm2squared(out double n2s);
    int normInfinity(out double ni);
    int minAbsCoef(out double scalar);
  };

  //// ... MANY other things in ESI
  interface VectorSimpleAccess {};
  interface VectorCommon{};
  interface VectorPointerAccess{};
  interface VectorReplaceAccess{};
  interface VectorOperations{};
  //........
};  // end package ESI


//=============================================================================
//  prototype of an ESI component
//=============================================================================

package ESIReference {
  class Vector implements ESI.VectorSimpleAccess,
                          ESI.VectorCommon,
                          ESI.VectorReplaceAccess,
                          ESI.VectorPointerAccess,
                          ESI.VectorOperations,
                          ESI.Vector,
                          CCA.Component,
                          DoubleArrayProducer.DirectPort {


    /** CCA.component functions */

    void setServices(in CCA.Services cc);
    CCA.Services getServices();


    /** DoubleArrayProducer.DirectPort */

    array<double,1> getArray();


    /** ESI.Vector functions */

    int clone(out ESI.Vector x) ;
      /// Clone source vector y to create target vector x.

    int getMap(out ESI.Map map) ;
      /// Get Map function.

    /** Assignment functions... */

    int put(in double scalar);
      /// y[i] = scalar for all i

    int scale(in double scalar);
      /// y <- y*scalar

    /** simple norms on y */
    int norm1(out double norm) ;
    int norm2(out double norm) ;
    int norm2squared(out double norm) ;
    int normInfinity(out double norm) ;

  /** nonstandard goodies */
    void setMap(in ESI.MapAlgebraic map);
      /// Construct a vector with a map.

  }; // end class Vector
}; // end package ESIReference

