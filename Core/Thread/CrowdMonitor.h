/*
 * This file was automatically generated by SCC - do NOT edit!
 * You should edit CrowdMonitor.scc instead 
 */

#ifndef SCI_THREAD_CROWDMONITOR_H
#define SCI_THREAD_CROWDMONITOR_H 1

/*
 * Multiple reader, single writer synchronization primitive.  Some
 * applications do not need the strict level of synchronization
 * provided by the <b>Mutex</b>.  The <b>CrowdMonitor</b> relaxes
 * the synchronization by allowing multiple threads access to a
 * resource (usually a data area), on the condition that the thread
 * will only read the data.  When a thread needs to write the data,
 * it can access the monitor in write mode (using <i>write_lock</i>).
 * At any given time, one writer thread can be active, or multiple
 * reader threads can be active.  <b>CrowdMonitor</b> guards against
 * multiple writers accessing a data, and against a thread writing
 * to the data while other threads are reading it.

 * <p> Calling <i>read_lock</i> within a <i>write_lock/write_unlock</i>
 * section may result in a deadlock.  Likewise, calling <i>write_lock</i>
 * within a <i>read_lock/read_unlock</i> section may result in a deadlock.
 * Calling <i>read_unlock</i> or <i>write_unlock</i> when the lock is
 * not held is not legal and may result in undefined behavior.
 */

#include "Mutex.h"
#include "ConditionVariable.h"




class CrowdMonitor_private;

/**************************************
 
CLASS
   CrowdMonitor
   
KEYWORDS
   CrowdMonitor
   
DESCRIPTION
   Multiple reader, single writer synchronization primitive.  Some
   applications do not need the strict level of synchronization
   provided by the <b>Mutex</b>.  The <b>CrowdMonitor</b> relaxes
   the synchronization by allowing multiple threads access to a
   resource (usually a data area), on the condition that the thread
   will only read the data.  When a thread needs to write the data,
   it can access the monitor in write mode (using <i>write_lock</i>).
   At any given time, one writer thread can be active, or multiple
   reader threads can be active.  <b>CrowdMonitor</b> guards against
   multiple writers accessing a data, and against a thread writing
   to the data while other threads are reading it.

   <p> Calling <i>read_lock</i> within a <i>write_lock/write_unlock</i>
   section may result in a deadlock.  Likewise, calling <i>write_lock</i>
   within a <i>read_lock/read_unlock</i> section may result in a deadlock.
   Calling <i>read_unlock</i> or <i>write_unlock</i> when the lock is
   not held is not legal and may result in undefined behavior.
PATTERNS


WARNING
   
****************************************/


class SCICORESHARE CrowdMonitor {
    const char* name;
    ConditionVariable write_waiters;
    ConditionVariable read_waiters;
    int nreaders_waiting;
    int nwriters_waiting;
    int nreaders;
    int nwriters;
    Mutex lock;
public:
    //////////
    //Create and initialize the CrowdMonitor. <i>name</i> should be a static string which
    //describes the primitive for debugging purposes.
    CrowdMonitor(const char* name) ;
    
    //////////
    //Destroy the CrowdMonitor.
    ~CrowdMonitor() ;
    
    //////////
    //Acquire the read-only lock associated with this <b>CrowdMonitor</b>.  Multiple threads
    //may hold the read-only lock.
    void read_lock() ;
    
    //////////
    //Release the read-only lock obtained from <i>read_lock</i>.  Undefined behavior may
    //result when <i>read_unlock</i> is called and a <i>read_lock</i> is not held.  
    void read_unlock() ;
    
    //////////
    //Acquire the write lock associated with this <b>CrowdMonitor</b>.  Only one thread may 
    //hold the write lock, and during the time that this lock is not held, no threads may hold  
    //the read-only lock.
    void write_lock() ;

    //////////
    //Release the write-only lock obtained from <i>write_lock</i>.  Undefined behavior may
    //result when <i>write_unlock</i> is called and a <i>write_lock</i> is not held.
    void write_unlock() ;
};

#endif


